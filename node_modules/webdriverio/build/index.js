var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/index.ts
import logger19 from "@wdio/logger";
import WebDriver, { DEFAULTS } from "webdriver";
import { validateConfig } from "@wdio/config";
import { enableFileLogging, wrapCommand as wrapCommand3 } from "@wdio/utils";

// src/multiremote.ts
import zip from "lodash.zip";
import clone2 from "lodash.clonedeep";
import { webdriverMonad as webdriverMonad2, wrapCommand as wrapCommand2 } from "@wdio/utils";

// src/middlewares.ts
import { ELEMENT_KEY as ELEMENT_KEY18 } from "webdriver";
import { getBrowserObject as getBrowserObject32 } from "@wdio/utils";

// src/utils/implicitWait.ts
import logger from "@wdio/logger";
var log = logger("webdriverio");
async function implicitWait(currentElement, commandName) {
  if (!currentElement.elementId && !commandName.match(/(waitUntil|waitFor|isExisting|is?\w+Displayed|is?\w+Clickable)/)) {
    log.debug(
      `command ${commandName} was called on an element ("${currentElement.selector}") that wasn't found, waiting for it...`
    );
    try {
      await currentElement.waitForExist();
      return currentElement.parent.$(currentElement.selector).getElement();
    } catch {
      if (currentElement.selector.toString().includes("this.previousElementSibling")) {
        throw new Error(
          `Can't call ${commandName} on previous element of element with selector "${currentElement.parent.selector}" because sibling wasn't found`
        );
      }
      if (currentElement.selector.toString().includes("this.nextElementSibling")) {
        throw new Error(
          `Can't call ${commandName} on next element of element with selector "${currentElement.parent.selector}" because sibling wasn't found`
        );
      }
      if (currentElement.selector.toString().includes("this.parentElement")) {
        throw new Error(
          `Can't call ${commandName} on parent element of element with selector "${currentElement.parent.selector}" because it wasn't found`
        );
      }
      throw new Error(
        `Can't call ${commandName} on element with selector "${currentElement.selector}" because element wasn't found`
      );
    }
  }
  return currentElement;
}

// src/utils/refetchElement.ts
async function refetchElement(currentElement, commandName) {
  const selectors = [];
  while (currentElement.elementId && currentElement.parent) {
    selectors.push({ selector: currentElement.selector, index: currentElement.index || 0 });
    currentElement = currentElement.parent;
  }
  selectors.reverse();
  const length = selectors.length;
  return selectors.reduce(async (elementPromise, { selector, index }, currentIndex) => {
    const resolvedElement = await elementPromise;
    let nextElement2 = index > 0 ? await resolvedElement.$$(selector)[index]?.getElement() : null;
    nextElement2 = nextElement2 || await resolvedElement.$(selector).getElement();
    return await implicitWait(nextElement2, currentIndex + 1 < length ? "$" : commandName);
  }, Promise.resolve(currentElement));
}

// src/utils/index.ts
import fs12 from "node:fs/promises";
import path3 from "node:path";
import { URL as URL2 } from "node:url";
import cssValue from "css-value";
import rgb2hex from "rgb2hex";
import GraphemeSplitter from "grapheme-splitter";
import logger18 from "@wdio/logger";
import isPlainObject from "is-plain-obj";
import { ELEMENT_KEY as ELEMENT_KEY17 } from "webdriver";
import { UNICODE_CHARACTERS as UNICODE_CHARACTERS2, asyncIterators, getBrowserObject as getBrowserObject31 } from "@wdio/utils";

// src/commands/browser.ts
var browser_exports = {};
__export(browser_exports, {
  $: () => $,
  $$: () => $$,
  SESSION_MOCKS: () => SESSION_MOCKS,
  action: () => action,
  actions: () => actions,
  addInitScript: () => addInitScript,
  call: () => call,
  custom$: () => custom$,
  custom$$: () => custom$$,
  debug: () => debug,
  deleteCookies: () => deleteCookies,
  downloadFile: () => downloadFile,
  emulate: () => emulate,
  execute: () => execute,
  executeAsync: () => executeAsync,
  getCookies: () => getCookies,
  getPuppeteer: () => getPuppeteer,
  getWindowSize: () => getWindowSize,
  keys: () => keys,
  mock: () => mock,
  mockClearAll: () => mockClearAll,
  mockRestoreAll: () => mockRestoreAll,
  newWindow: () => newWindow,
  pause: () => pause,
  react$: () => react$,
  react$$: () => react$$,
  reloadSession: () => reloadSession,
  restore: () => restore,
  savePDF: () => savePDF,
  saveRecordingScreen: () => saveRecordingScreen,
  saveScreenshot: () => saveScreenshot,
  scroll: () => scroll,
  setCookies: () => setCookies,
  setTimeout: () => setTimeout2,
  setViewport: () => setViewport,
  setWindowSize: () => setWindowSize,
  switchWindow: () => switchWindow,
  throttle: () => throttle,
  throttleCPU: () => throttleCPU,
  throttleNetwork: () => throttleNetwork,
  touchAction: () => touchAction2,
  uploadFile: () => uploadFile,
  url: () => url3,
  waitUntil: () => waitUntil
});

// src/utils/getElementObject.ts
import { webdriverMonad, wrapCommand } from "@wdio/utils";
import clone from "lodash.clonedeep";
import { ELEMENT_KEY } from "webdriver";
import { getBrowserObject } from "@wdio/utils";
var WebDriverError = class extends Error {
  constructor(obj) {
    const { name, stack } = obj;
    const { error, stacktrace } = obj;
    super(error || name || "");
    Object.assign(this, {
      message: obj.message,
      stack: stacktrace || stack
    });
  }
};
var getElement = function findElement(selector, res, props = { isReactElement: false, isShadowElement: false }) {
  const browser = getBrowserObject(this);
  const browserCommandKeys = Object.keys(browser_exports);
  const propertiesObject = {
    /**
     * filter out browser commands from object
     */
    ...Object.entries(clone(browser.__propertiesObject__)).reduce((commands, [name, descriptor]) => {
      if (!browserCommandKeys.includes(name)) {
        commands[name] = descriptor;
      }
      return commands;
    }, {}),
    ...getPrototype("element"),
    scope: { value: "element" }
  };
  propertiesObject.emit = { value: this.emit.bind(this) };
  const element = webdriverMonad(this.options, (client) => {
    const elementId = getElementFromResponse(res);
    if (elementId) {
      client.elementId = elementId;
      client[ELEMENT_KEY] = elementId;
      if (res && this.isBidi && "locator" in res) {
        client.locator = res.locator;
      }
    } else {
      client.error = res;
    }
    if (selector) {
      client.selector = selector;
    }
    client.parent = this;
    client.isReactElement = props.isReactElement;
    client.isShadowElement = props.isShadowElement;
    return client;
  }, propertiesObject);
  const elementInstance = element(this.sessionId, elementErrorHandler(wrapCommand));
  const origAddCommand = elementInstance.addCommand.bind(elementInstance);
  elementInstance.addCommand = (name, fn) => {
    browser.__propertiesObject__[name] = { value: fn };
    origAddCommand(name, fn);
  };
  return elementInstance;
};
var getElements = function getElements2(selector, elemResponse, props = { isReactElement: false, isShadowElement: false }) {
  const browser = getBrowserObject(this);
  const browserCommandKeys = Object.keys(browser_exports);
  const propertiesObject = {
    /**
     * filter out browser commands from object
     */
    ...Object.entries(clone(browser.__propertiesObject__)).reduce((commands, [name, descriptor]) => {
      if (!browserCommandKeys.includes(name)) {
        commands[name] = descriptor;
      }
      return commands;
    }, {}),
    ...getPrototype("element")
  };
  if (elemResponse.length === 0) {
    return [];
  }
  const elements = [elemResponse].flat(1).map((res, i) => {
    if (res.selector && "$$" in res) {
      return res;
    }
    propertiesObject.scope = { value: "element" };
    propertiesObject.emit = { value: this.emit.bind(this) };
    const element = webdriverMonad(this.options, (client) => {
      const elementId = getElementFromResponse(res);
      if (elementId) {
        client.elementId = elementId;
        client[ELEMENT_KEY] = elementId;
        if (res && this.isBidi && "locator" in res) {
          client.locator = res.locator;
        }
      } else {
        res = res;
        client.error = res instanceof Error ? res : new WebDriverError(res);
      }
      client.selector = Array.isArray(selector) ? selector[i].selector : selector;
      client.parent = this;
      client.index = i;
      client.isReactElement = props.isReactElement;
      client.isShadowElement = props.isShadowElement;
      return client;
    }, propertiesObject);
    const elementInstance = element(this.sessionId, elementErrorHandler(wrapCommand));
    const origAddCommand = elementInstance.addCommand.bind(elementInstance);
    elementInstance.addCommand = (name, fn) => {
      browser.__propertiesObject__[name] = { value: fn };
      origAddCommand(name, fn);
    };
    return elementInstance;
  });
  return elements;
};

// src/constants.ts
import { UNICODE_CHARACTERS, HOOK_DEFINITION } from "@wdio/utils";
var SupportedAutomationProtocols = /* @__PURE__ */ ((SupportedAutomationProtocols2) => {
  SupportedAutomationProtocols2["webdriver"] = "webdriver";
  SupportedAutomationProtocols2["stub"] = "./protocol-stub.js";
  return SupportedAutomationProtocols2;
})(SupportedAutomationProtocols || {});
var WDIO_DEFAULTS = {
  /**
   * allows to specify automation protocol
   */
  automationProtocol: {
    type: "string",
    default: "webdriver" /* webdriver */,
    validate: (param) => {
      if (param.endsWith("driver.js")) {
        return;
      }
      if (!Object.values(SupportedAutomationProtocols).includes(param.toLowerCase())) {
        throw new Error(`Currently only "webdriver" and "devtools" is supported as automationProtocol, you set "${param}"`);
      }
    }
  },
  /**
   * capabilities of WebDriver sessions
   */
  capabilities: {
    type: "object",
    validate: (param) => {
      if (typeof param === "object") {
        return true;
      }
      throw new Error('the "capabilities" options needs to be an object or a list of objects');
    },
    required: true
  },
  /**
   * Shorten navigateTo command calls by setting a base url
   */
  baseUrl: {
    type: "string"
  },
  /**
   * Default interval for all waitFor* commands
   */
  waitforInterval: {
    type: "number",
    default: 500
  },
  /**
   * Default timeout for all waitFor* commands
   */
  waitforTimeout: {
    type: "number",
    default: 5e3
  },
  /**
   * Hooks
   */
  onReload: HOOK_DEFINITION,
  beforeCommand: HOOK_DEFINITION,
  afterCommand: HOOK_DEFINITION
};
var FF_REMOTE_DEBUG_ARG = "-remote-debugging-port";
var DEEP_SELECTOR = ">>>";
var ARIA_SELECTOR = "aria/";
var restoreFunctions = /* @__PURE__ */ new Map();
var Key = {
  /**
   * Special control key that works cross browser for Mac, where it's the command key, and for
   * Windows or Linux, where it is the control key.
   */
  Ctrl: "WDIO_CONTROL",
  NULL: UNICODE_CHARACTERS.NULL,
  Cancel: UNICODE_CHARACTERS.Cancel,
  Help: UNICODE_CHARACTERS.Help,
  Backspace: UNICODE_CHARACTERS.Backspace,
  Tab: UNICODE_CHARACTERS.Tab,
  Clear: UNICODE_CHARACTERS.Clear,
  Return: UNICODE_CHARACTERS.Return,
  Enter: UNICODE_CHARACTERS.Enter,
  Shift: UNICODE_CHARACTERS.Shift,
  Control: UNICODE_CHARACTERS.Control,
  Alt: UNICODE_CHARACTERS.Alt,
  Pause: UNICODE_CHARACTERS.Pause,
  Escape: UNICODE_CHARACTERS.Escape,
  Space: UNICODE_CHARACTERS.Space,
  PageUp: UNICODE_CHARACTERS.PageUp,
  PageDown: UNICODE_CHARACTERS.PageDown,
  End: UNICODE_CHARACTERS.End,
  Home: UNICODE_CHARACTERS.Home,
  ArrowLeft: UNICODE_CHARACTERS.ArrowLeft,
  ArrowUp: UNICODE_CHARACTERS.ArrowUp,
  ArrowRight: UNICODE_CHARACTERS.ArrowRight,
  ArrowDown: UNICODE_CHARACTERS.ArrowDown,
  Insert: UNICODE_CHARACTERS.Insert,
  Delete: UNICODE_CHARACTERS.Delete,
  Semicolon: UNICODE_CHARACTERS.Semicolon,
  Equals: UNICODE_CHARACTERS.Equals,
  Numpad0: UNICODE_CHARACTERS["Numpad 0"],
  Numpad1: UNICODE_CHARACTERS["Numpad 1"],
  Numpad2: UNICODE_CHARACTERS["Numpad 2"],
  Numpad3: UNICODE_CHARACTERS["Numpad 3"],
  Numpad4: UNICODE_CHARACTERS["Numpad 4"],
  Numpad5: UNICODE_CHARACTERS["Numpad 5"],
  Numpad6: UNICODE_CHARACTERS["Numpad 6"],
  Numpad7: UNICODE_CHARACTERS["Numpad 7"],
  Numpad8: UNICODE_CHARACTERS["Numpad 8"],
  Numpad9: UNICODE_CHARACTERS["Numpad 9"],
  Multiply: UNICODE_CHARACTERS.Multiply,
  Add: UNICODE_CHARACTERS.Add,
  Separator: UNICODE_CHARACTERS.Separator,
  Subtract: UNICODE_CHARACTERS.Subtract,
  Decimal: UNICODE_CHARACTERS.Decimal,
  Divide: UNICODE_CHARACTERS.Divide,
  F1: UNICODE_CHARACTERS.F1,
  F2: UNICODE_CHARACTERS.F2,
  F3: UNICODE_CHARACTERS.F3,
  F4: UNICODE_CHARACTERS.F4,
  F5: UNICODE_CHARACTERS.F5,
  F6: UNICODE_CHARACTERS.F6,
  F7: UNICODE_CHARACTERS.F7,
  F8: UNICODE_CHARACTERS.F8,
  F9: UNICODE_CHARACTERS.F9,
  F10: UNICODE_CHARACTERS.F10,
  F11: UNICODE_CHARACTERS.F11,
  F12: UNICODE_CHARACTERS.F12,
  Command: UNICODE_CHARACTERS.Command,
  ZenkakuHankaku: UNICODE_CHARACTERS.ZenkakuHankaku
};

// src/commands/browser/$$.ts
async function $$(selector) {
  if (this.isBidi && typeof selector === "string" && !selector.startsWith(DEEP_SELECTOR)) {
    if (globalThis.wdio?.execute) {
      const command = "$$";
      const res3 = "elementId" in this ? await globalThis.wdio.executeWithScope(command, this.elementId, selector) : await globalThis.wdio.execute(command, selector);
      const elements3 = await getElements.call(this, selector, res3);
      return enhanceElementsArray(elements3, this, selector);
    }
    const res2 = await findDeepElements.call(this, selector);
    const elements2 = await getElements.call(this, selector, res2);
    return enhanceElementsArray(elements2, getParent.call(this, res2), selector);
  }
  let res = Array.isArray(selector) ? selector : await findElements.call(this, selector);
  if (Array.isArray(selector) && isElement(selector[0])) {
    res = [];
    for (const el of selector) {
      const $el = await findElement2.call(this, el);
      $el && res.push($el);
    }
  }
  const elements = await getElements.call(this, selector, res);
  return enhanceElementsArray(elements, getParent.call(this, res), selector);
}
function getParent(res) {
  let parent = res.length > 0 ? res[0].parent || this : this;
  if (typeof parent.$ === "undefined") {
    parent = "selector" in parent ? getElement.call(this, parent.selector, parent) : this;
  }
  return parent;
}

// src/commands/browser/$.ts
import { ELEMENT_KEY as ELEMENT_KEY2 } from "webdriver";
async function $(selector) {
  if (globalThis.wdio && typeof selector === "string" && !selector.startsWith(DEEP_SELECTOR)) {
    const res2 = "elementId" in this ? await globalThis.wdio.executeWithScope("$", this.elementId, selector) : await globalThis.wdio.execute("$", selector);
    return getElement.call(this, selector, res2);
  }
  if (typeof selector === "object") {
    const elementRef = selector;
    if (typeof elementRef[ELEMENT_KEY2] === "string") {
      return getElement.call(this, void 0, elementRef);
    }
  }
  const res = await findElement2.call(this, selector);
  return getElement.call(this, selector, res);
}

// src/utils/actions/key.ts
import os from "node:os";

// src/utils/actions/base.ts
import { ELEMENT_KEY as ELEMENT_KEY3 } from "webdriver";
var actionIds = 0;
var BaseAction = class {
  constructor(instance, type, params) {
    this.instance = instance;
    this.#instance = instance;
    this.#id = params?.id || `action${++actionIds}`;
    this.#type = type;
    this.#parameters = params?.parameters || {};
  }
  #id;
  #type;
  #parameters;
  #instance;
  sequence = [];
  toJSON() {
    return {
      id: this.#id,
      type: this.#type,
      parameters: this.#parameters,
      actions: this.sequence
    };
  }
  /**
   * Inserts a pause action for the specified device, ensuring it idles for a tick.
   * @param duration idle time of tick
   */
  pause(duration) {
    this.sequence.push({ type: "pause", duration });
    return this;
  }
  /**
   * Perform action sequence
   * @param skipRelease set to true if `releaseActions` command should not be invoked
   */
  async perform(skipRelease = false) {
    for (const seq of this.sequence) {
      if (!seq.origin || typeof seq.origin === "string") {
        continue;
      }
      if (typeof seq.origin.then === "function") {
        await seq.origin.waitForExist();
        seq.origin = await seq.origin;
      }
      if (!seq.origin[ELEMENT_KEY3]) {
        throw new Error(`Couldn't find element for "${seq.type}" action sequence`);
      }
      seq.origin = { [ELEMENT_KEY3]: seq.origin[ELEMENT_KEY3] };
    }
    await this.#instance.performActions([this.toJSON()]);
    if (!skipRelease) {
      await this.#instance.releaseActions();
    }
  }
};

// src/utils/actions/key.ts
var KeyAction = class extends BaseAction {
  constructor(instance, params) {
    super(instance, "key", params);
  }
  #sanitizeKey(value) {
    if (typeof value !== "string") {
      throw new Error(`Invalid type for key input: "${typeof value}", expected a string!`);
    }
    const platformName = this.instance.capabilities.platformName;
    const isMac = (
      // check capabilities first
      platformName && platformName.match(/mac(\s)*os/i) || // if not set, expect we run locally
      this.instance.options.hostname?.match(/0\.0\.0\.0|127\.0\.0\.1|local/i) && os.type().match(/darwin/i)
    );
    if (value === Key.Ctrl) {
      return isMac ? Key.Command : Key.Control;
    }
    if (value.length > 1) {
      throw new Error(`Your key input contains more than one character: "${value}", only one is allowed though!`);
    }
    return value;
  }
  /**
   * Generates a key up action.
   * @param value key value
   */
  up(value) {
    this.sequence.push({ type: "keyUp", value: this.#sanitizeKey(value) });
    return this;
  }
  /**
   * Generates a key down action.
   * @param value key value
   */
  down(value) {
    this.sequence.push({ type: "keyDown", value: this.#sanitizeKey(value) });
    return this;
  }
};

// src/utils/actions/pointer.ts
var buttonNumbers = [0, 1, 2];
var buttonNames = ["left", "middle", "right"];
var buttonValue = [...buttonNumbers, ...buttonNames];
var ORIGIN_DEFAULT = "viewport";
var BUTTON_DEFAULT = 0;
var POINTER_TYPE_DEFAULT = "mouse";
var UP_PARAM_DEFAULTS = {
  button: BUTTON_DEFAULT
};
var PARAM_DEFAULTS = {
  ...UP_PARAM_DEFAULTS,
  width: 0,
  height: 0,
  pressure: 0,
  tangentialPressure: 0,
  tiltX: 0,
  tiltY: 0,
  twist: 0,
  altitudeAngle: 0,
  azimuthAngle: 0
};
var MOVE_PARAM_DEFAULTS = {
  x: 0,
  y: 0,
  duration: 100,
  origin: ORIGIN_DEFAULT
};
function mapButton(params) {
  const buttons = {
    left: 0,
    middle: 1,
    right: 2
  };
  if (typeof params === "number") {
    return { button: params };
  }
  if (typeof params === "string") {
    return { button: buttons[params] };
  }
  if (typeof params === "object" && typeof params.button === "string") {
    return { ...params, button: buttons[params.button] };
  }
  return params;
}
var PointerAction = class extends BaseAction {
  constructor(instance, params = {}) {
    if (!params.parameters) {
      params.parameters = { pointerType: POINTER_TYPE_DEFAULT };
    }
    super(instance, "pointer", params);
  }
  move(params = {}, y) {
    const seq = {
      type: "pointerMove",
      // default params
      ...PARAM_DEFAULTS,
      ...UP_PARAM_DEFAULTS,
      ...MOVE_PARAM_DEFAULTS
    };
    if (typeof params === "number") {
      Object.assign(seq, { x: params, y });
    } else if (params) {
      Object.assign(seq, params);
    }
    this.sequence.push(seq);
    return this;
  }
  up(params = UP_PARAM_DEFAULTS) {
    this.sequence.push({
      type: "pointerUp",
      ...mapButton(params)
    });
    return this;
  }
  down(params = {}) {
    this.sequence.push({
      type: "pointerDown",
      ...PARAM_DEFAULTS,
      ...mapButton(params)
    });
    return this;
  }
  /**
   * An action that cancels this pointer's current input.
   */
  cancel() {
    this.sequence.push({ type: "pointerCancel" });
    return this;
  }
};

// src/utils/actions/wheel.ts
var DEFAULT_SCROLL_PARAMS = {
  x: 0,
  y: 0,
  deltaX: 0,
  deltaY: 0,
  duration: 0
};
var WheelAction = class extends BaseAction {
  constructor(instance, params) {
    super(instance, "wheel", params);
  }
  /**
   * Scrolls a page to given coordinates or origin.
   */
  scroll(params) {
    this.sequence.push({ type: "scroll", ...DEFAULT_SCROLL_PARAMS, ...params });
    return this;
  }
};

// src/commands/browser/action.ts
function action(type, opts) {
  if (type === "key") {
    return new KeyAction(this, opts);
  }
  if (type === "pointer") {
    return new PointerAction(this, opts);
  }
  if (type === "wheel") {
    return new WheelAction(this, opts);
  }
  throw new Error(`Unsupported action type "${type}", supported are "key", "pointer", "wheel"`);
}

// src/commands/browser/actions.ts
async function actions(actions2) {
  await this.performActions(actions2.map((action2) => action2.toJSON()));
  await this.releaseActions();
}

// src/commands/browser/addInitScript.ts
import { EventEmitter } from "node:events";

// src/utils/bidi/index.ts
import { ELEMENT_KEY as ELEMENT_KEY4 } from "webdriver";
function parseScriptResult(result) {
  const type = result.type;
  if (type === "success" /* Success */) {
    return deserializeValue(result.result);
  }
  if (type === "exception" /* Exception */) {
    const columnNumber = "columnNumber" in result.exceptionDetails ? result.exceptionDetails.columnNumber : null;
    const exception = "exception" in result.exceptionDetails ? result.exceptionDetails.exception : null;
    const lineNumber = "lineNumber" in result.exceptionDetails ? result.exceptionDetails.lineNumber : null;
    const stackTrace = "stackTrace" in result.exceptionDetails ? result.exceptionDetails.stackTrace : null;
    const text = "text" in result.exceptionDetails ? result.exceptionDetails.text : null;
    return {
      error: {
        message: text,
        columnNumber,
        exception,
        lineNumber,
        stackTrace
      }
    };
  }
  throw new Error(`Unknown evaluate result type: ${type}`);
}
function deserializeValue(result) {
  const { type, value } = result;
  if (type === "regexp" /* RegularExpression */) {
    return new RegExp(value.pattern, value.flags);
  }
  if (type === "array" /* Array */) {
    return value.map((element) => deserializeValue(element));
  }
  if (type === "date" /* Date */) {
    return new Date(value);
  }
  if (type === "map" /* Map */) {
    return new Map(value.map(([key, value2]) => [typeof key === "string" ? key : deserializeValue(key), deserializeValue(value2)]));
  }
  if (type === "set" /* Set */) {
    return new Set(value.map((element) => deserializeValue(element)));
  }
  if (type === "number" /* Number */ && value === "NaN") {
    return NaN;
  }
  if (type === "number" /* Number */ && value === "Infinity") {
    return Infinity;
  }
  if (type === "number" /* Number */ && value === "-Infinity") {
    return -Infinity;
  }
  if (type === "number" /* Number */ && value === "-0") {
    return -0;
  }
  if (type === "bigint" /* BigInt */) {
    return BigInt(value);
  }
  if (type === "null" /* Null */) {
    return null;
  }
  if (type === "object" /* Object */) {
    return Object.fromEntries((value || []).map(([key, value2]) => {
      return [typeof key === "string" ? key : deserializeValue(key), deserializeValue(value2)];
    }));
  }
  if (type === "node" /* Node */) {
    return { [ELEMENT_KEY4]: result.sharedId };
  }
  return value;
}

// src/commands/browser/addInitScript.ts
async function addInitScript(script, ...args) {
  if (typeof script !== "function") {
    throw new Error("The `addInitScript` command requires a function as first parameter, but got: " + typeof script);
  }
  if (!this.isBidi) {
    throw new Error("This command is only supported when automating browser using WebDriver Bidi protocol");
  }
  const serializedParameters = (args || []).map((arg) => JSON.stringify(arg));
  const context = await this.getWindowHandle();
  const fn = `(emit) => {
        const closure = new Function(\`return ${script.toString()}\`)
        return closure()(${serializedParameters.length ? `${serializedParameters.join(", ")}, emit` : "emit"})
    }`;
  const channel = btoa(fn.toString());
  const result = await this.scriptAddPreloadScript({
    functionDeclaration: fn,
    arguments: [{
      type: "channel",
      value: { channel }
    }],
    contexts: [context]
  });
  await this.sessionSubscribe({
    events: ["script.message"]
  });
  const emitter = new EventEmitter();
  const messageHandler = (msg) => {
    if (msg.channel === channel) {
      emitter.emit("data", deserializeValue(msg.data));
    }
  };
  this.on("script.message", messageHandler);
  const resetFn = () => {
    this.off("script.message", messageHandler);
    return this.scriptRemovePreloadScript({ script: result.script });
  };
  const returnVal = {
    remove: resetFn,
    on: emitter.on.bind(emitter)
  };
  return returnVal;
}

// src/commands/browser/call.ts
function call(fn) {
  if (typeof fn === "function") {
    return fn();
  }
  throw new Error('Command argument for "call" needs to be a function');
}

// src/commands/browser/custom$$.ts
import { ELEMENT_KEY as ELEMENT_KEY5 } from "webdriver";
async function custom$$(strategyName, ...strategyArguments) {
  const strategy = this.strategies.get(strategyName);
  if (!strategy) {
    throw Error("No strategy found for " + strategyName);
  }
  const strategyRef = { strategy, strategyName, strategyArguments };
  let res = await this.execute(strategy, ...strategyArguments);
  if (!Array.isArray(res)) {
    res = [res];
  }
  res = res.filter((el) => !!el && typeof el[ELEMENT_KEY5] === "string");
  const elements = res.length ? await getElements.call(this, strategyRef, res) : [];
  return enhanceElementsArray(elements, this, strategyName, "custom$$", strategyArguments);
}

// src/commands/browser/custom$.ts
import { ELEMENT_KEY as ELEMENT_KEY6 } from "webdriver";
async function custom$(strategyName, ...strategyArguments) {
  const strategy = this.strategies.get(strategyName);
  if (!strategy) {
    throw Error("No strategy found for " + strategyName);
  }
  const strategyRef = { strategy, strategyName, strategyArguments };
  let res = await this.execute(strategy, ...strategyArguments);
  if (Array.isArray(res)) {
    res = res[0];
  }
  if (res && typeof res[ELEMENT_KEY6] === "string") {
    return await getElement.call(this, strategyRef, res);
  }
  return await getElement.call(this, strategyRef, new Error("no such element"));
}

// src/commands/browser/debug.ts
import { serializeError } from "serialize-error";
import WDIORepl from "@wdio/repl";
function debug(commandTimeout = 5e3) {
  const repl = new WDIORepl();
  const { introMessage } = WDIORepl;
  if (!process.env.WDIO_WORKER_ID || typeof process.send !== "function") {
    console.log(WDIORepl.introMessage);
    const context = {
      browser: this,
      driver: this,
      $: this.$.bind(this),
      $$: this.$$.bind(this)
    };
    return repl.start(context);
  }
  process._debugProcess(process.pid);
  process.send({
    origin: "debugger",
    name: "start",
    params: { commandTimeout, introMessage }
  });
  let commandResolve = (
    /* istanbul ignore next */
    () => {
    }
  );
  process.on("message", (m) => {
    if (m.origin !== "debugger") {
      return;
    }
    if (m.name === "stop") {
      process._debugEnd(process.pid);
      return commandResolve();
    }
    if (m.name === "eval") {
      repl.eval(m.content.cmd, global, void 0, (err, result) => {
        if (typeof process.send !== "function") {
          return;
        }
        if (err) {
          process.send({
            origin: "debugger",
            name: "result",
            params: {
              error: true,
              ...serializeError(err)
            }
          });
        }
        if (typeof result === "function") {
          result = `[Function: ${result.name}]`;
        }
        process.send({
          origin: "debugger",
          name: "result",
          params: { result }
        });
      });
    }
  });
  return new Promise((resolve5) => commandResolve = resolve5);
}

// src/commands/browser/deleteCookies.ts
function deleteCookies(names) {
  if (names === void 0) {
    return this.deleteAllCookies();
  }
  const namesList = Array.isArray(names) ? names : [names];
  if (namesList.every((obj) => typeof obj !== "string")) {
    return Promise.reject(new Error("Invalid input (see https://webdriver.io/docs/api/browser/deleteCookies for documentation)"));
  }
  return Promise.all(namesList.map((name) => this.deleteCookie(name)));
}

// src/commands/browser/downloadFile.ts
import fs from "node:fs";
import path from "node:path";
import JSZip from "jszip";
import logger2 from "@wdio/logger";
var log2 = logger2("webdriverio");
async function downloadFile(fileName, targetDirectory) {
  if (typeof fileName !== "string" || typeof targetDirectory !== "string") {
    throw new Error("number or type of arguments don't agree with downloadFile command");
  }
  if (typeof this.download !== "function") {
    throw new Error(`The downloadFile command is not available in ${this.capabilities.browserName} and only available when using Selenium Grid`);
  }
  const response = await this.download(fileName);
  const base64Content = response.contents;
  if (!targetDirectory.endsWith("/")) {
    targetDirectory += "/";
  }
  fs.mkdirSync(targetDirectory, { recursive: true });
  const zipFilePath = path.join(targetDirectory, `${fileName}.zip`);
  fs.writeFileSync(zipFilePath, Buffer.from(base64Content, "base64"));
  const zipData = fs.readFileSync(zipFilePath);
  const filesData = [];
  try {
    const zip2 = await JSZip.loadAsync(zipData);
    const keys2 = Object.keys(zip2.files);
    for (let i = 0; i < keys2.length; i++) {
      const fileData = await zip2.files[keys2[i]].async("nodebuffer");
      const dir = path.resolve(targetDirectory, keys2[i]);
      fs.writeFileSync(dir, fileData);
      log2.info(`File extracted: ${keys2[i]}`);
      filesData.push(dir);
    }
  } catch (error) {
    log2.error("Error unzipping file:", error);
  }
  return Promise.resolve({
    files: filesData
  });
}

// src/clock.ts
import logger3 from "@wdio/logger";
var log3 = logger3("webdriverio:ClockManager");
function installFakeTimers(options) {
  window.__clock = window.__wdio_sinon.install(options);
}
function uninstallFakeTimers() {
  window.__clock.uninstall();
}
var ClockManager = class {
  #browser;
  #resetFn = () => Promise.resolve();
  #isInstalled = false;
  constructor(browser) {
    this.#browser = browser;
  }
  /**
   * Install fake timers on the browser. If you call the `emulate` command, WebdriverIO will automatically install
   * the fake timers for you. You can use this method to re-install the fake timers if you have called `restore`.
   *
   * @param options {FakeTimerInstallOpts} Options to pass to the fake clock
   * @returns {Promise<void>}
   */
  async install(options) {
    if (this.#isInstalled) {
      return log3.warn("Fake timers are already installed");
    }
    if (globalThis.window) {
      return;
    }
    const url6 = await import("node:url");
    const path4 = await import("node:path");
    const fs13 = await import("node:fs/promises");
    const __dirname = path4.dirname(url6.fileURLToPath(import.meta.url));
    const rootDir = path4.resolve(__dirname, "..");
    const emulateOptions = options || {};
    const scriptPath = path4.join(rootDir, "third_party", "fake-timers.js");
    const functionDeclaration = await fs13.readFile(scriptPath, "utf-8");
    const installOptions = {
      ...emulateOptions,
      now: emulateOptions.now && emulateOptions.now instanceof Date ? emulateOptions.now.getTime() : emulateOptions.now
    };
    const [, libScript, restoreInstallScript] = await Promise.all([
      /**
       * install fake timers for current ex
       */
      this.#browser.executeScript(`return (${functionDeclaration}).apply(null, arguments)`, []).then(() => this.#browser.execute(installFakeTimers, installOptions)),
      /**
       * add preload script to to emulate clock for upcoming page loads
       */
      this.#browser.scriptAddPreloadScript({ functionDeclaration }),
      this.#browser.addInitScript(installFakeTimers, installOptions)
    ]);
    this.#resetFn = async () => Promise.all([
      this.#browser.scriptRemovePreloadScript({ script: libScript.script }),
      this.#browser.execute(uninstallFakeTimers),
      restoreInstallScript
    ]);
    this.#isInstalled = true;
  }
  /**
   * Restore all overridden native functions. This is automatically called between tests, so should not
   * generally be needed.
   *
   * ```ts
   * it('should restore the clock', async () => {
   *   console.log(new Date()) // returns e.g. 1722560447102
   *
   *   const clock = await browser.emulate('clock', { now: new Date(2021, 3, 14) })
   *   console.log(await browser.execute(() => new Date().getTime())) // returns 1618383600000
   *
   *   await clock.restore()
   *   console.log(await browser.execute(() => new Date().getTime())) // returns 1722560447102
   * })
   * ```
   *
   * @returns {Promise<void>}
   */
  async restore() {
    await this.#resetFn();
    this.#isInstalled = false;
  }
  /**
   * Move the clock the specified number of `milliseconds`. Any timers within the affected range of time will be called.
   * @param ms {number} The number of milliseconds to move the clock.
   *
   * ```ts
   * it('should move the clock', async () => {
   *   console.log(new Date()) // returns e.g. 1722560447102
   *
   *   const clock = await browser.emulate('clock', { now: new Date(2021, 3, 14) })
   *   console.log(await browser.execute(() => new Date().getTime())) // returns 1618383600000
   *
   *   await clock.tick(1000)
   *   console.log(await browser.execute(() => new Date().getTime())) // returns 1618383601000
   * })
   * ```
   *
   * @param    {number}  ms  The number of milliseconds to move the clock.
   * @returns  {Promise<void>}
   */
  async tick(ms) {
    await this.#browser.execute((ms2) => window.__clock.tick(ms2), ms);
  }
  /**
   * Change the system time to the new now. Now can be a timestamp, date object, or not passed in which defaults
   * to 0. No timers will be called, nor will the time left before they trigger change.
   *
   * ```ts
   * it('should set the system time', async () => {
   *   const clock = await browser.emulate('clock', { now: new Date(2021, 3, 14) })
   *   console.log(await browser.execute(() => new Date().getTime())) // returns 1618383600000
   *
   *   await clock.setSystemTime(new Date(2011, 3, 15))
   *   console.log(await browser.execute(() => new Date().getTime())) // returns 1302850800000
   * })
   * ```
   *
   * @param date {Date|number} The new date to set the system time to.
   * @returns    {Promise<void>}
   */
  async setSystemTime(date) {
    const serializableSystemTime = date instanceof Date ? date.getTime() : date;
    await this.#browser.execute((date2) => window.__clock.setSystemTime(date2), serializableSystemTime);
  }
};

// src/deviceDescriptorsSource.ts
var deviceDescriptorsSource = {
  "Blackberry PlayBook": {
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/18.0 Safari/536.2+",
    viewport: {
      width: 600,
      height: 1024
    },
    deviceScaleFactor: 1,
    isMobile: true,
    hasTouch: true
  },
  "Blackberry PlayBook landscape": {
    userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/18.0 Safari/536.2+",
    viewport: {
      width: 1024,
      height: 600
    },
    deviceScaleFactor: 1,
    isMobile: true,
    hasTouch: true
  },
  "BlackBerry Z30": {
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/18.0 Mobile Safari/537.10+",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "BlackBerry Z30 landscape": {
    userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/18.0 Mobile Safari/537.10+",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy Note 3": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy Note 3 landscape": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy Note II": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy Note II landscape": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S III": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.0 Mobile Safari/534.30",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S III landscape": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/18.0 Mobile Safari/534.30",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S5": {
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S5 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S8": {
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 740
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S8 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 740,
      height: 360
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S9 +": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 320,
      height: 658
    },
    deviceScaleFactor: 4.5,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy S9 + landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 658,
      height: 320
    },
    deviceScaleFactor: 4.5,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy Tab S4": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 712,
      height: 1138
    },
    deviceScaleFactor: 2.25,
    isMobile: true,
    hasTouch: true
  },
  "Galaxy Tab S4 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 1138,
      height: 712
    },
    deviceScaleFactor: 2.25,
    isMobile: true,
    hasTouch: true
  },
  "iPad(gen 5)": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 768,
      height: 1024
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad(gen 5) landscape": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1024,
      height: 768
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad(gen 6)": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 768,
      height: 1024
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad(gen 6) landscape": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1024,
      height: 768
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad(gen 7)": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 810,
      height: 1080
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad(gen 7) landscape": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1080,
      height: 810
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad Mini": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 768,
      height: 1024
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad Mini landscape": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1024,
      height: 768
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad Pro 11": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 834,
      height: 1194
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPad Pro 11 landscape": {
    userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 1194,
      height: 834
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 6": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 6 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 6 Plus": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 6 Plus landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 7": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 7 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 7 Plus": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 7 Plus landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 8": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 667
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 8 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 667,
      height: 375
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 8 Plus": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 414,
      height: 736
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 8 Plus landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 736,
      height: 414
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone SE": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/18.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 320,
      height: 568
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone SE landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/18.0 Mobile/14E304 Safari/602.1",
    viewport: {
      width: 568,
      height: 320
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone X": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 375,
      height: 812
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone X landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/18.0 Mobile/15A372 Safari/604.1",
    viewport: {
      width: 812,
      height: 375
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone XR": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 896
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone XR landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 896,
      height: 414
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 11": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 715
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 11 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 800,
      height: 364
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 11 Pro": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 635
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 11 Pro landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 724,
      height: 325
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 11 Pro Max": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 414,
      height: 715
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 11 Pro Max landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 808,
      height: 364
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 664
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 340
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12 Pro": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 664
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12 Pro landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 340
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12 Pro Max": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 746
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12 Pro Max landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 832,
      height: 378
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12 Mini": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 629
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 12 Mini landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 712,
      height: 325
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 664
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 342
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13 Pro": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 664
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13 Pro landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 342
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13 Pro Max": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 746
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13 Pro Max landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 832,
      height: 380
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13 Mini": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 375,
      height: 629
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 13 Mini landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 712,
      height: 327
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 390,
      height: 664
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 750,
      height: 340
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14 Plus": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 428,
      height: 746
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14 Plus landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 832,
      height: 378
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14 Pro": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 660
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14 Pro landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14 Pro Max": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 740
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 14 Pro Max landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15 landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15 Plus": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15 Plus landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15 Pro": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 393,
      height: 659
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15 Pro landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 734,
      height: 343
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15 Pro Max": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 430,
      height: 739
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "iPhone 15 Pro Max landscape": {
    userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_5 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Mobile/15E148 Safari/604.1",
    viewport: {
      width: 814,
      height: 380
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Kindle Fire HDX": {
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 800,
      height: 1280
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Kindle Fire HDX landscape": {
    userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
    viewport: {
      width: 1280,
      height: 800
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "LG Optimus L70": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640
    },
    deviceScaleFactor: 1.25,
    isMobile: true,
    hasTouch: true
  },
  "LG Optimus L70 landscape": {
    userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384
    },
    deviceScaleFactor: 1.25,
    isMobile: true,
    hasTouch: true
  },
  "Microsoft Lumia 550": {
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Microsoft Lumia 550 landscape": {
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Microsoft Lumia 950": {
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 4,
    isMobile: true,
    hasTouch: true
  },
  "Microsoft Lumia 950 landscape": {
    userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36 Edge/14.14263",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 4,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 10": {
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 800,
      height: 1280
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 10 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 1280,
      height: 800
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 4": {
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 384,
      height: 640
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 4 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 384
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 5": {
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 5 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 5X": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732
    },
    deviceScaleFactor: 2.625,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 5X landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412
    },
    deviceScaleFactor: 2.625,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 6": {
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732
    },
    deviceScaleFactor: 3.5,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 6 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412
    },
    deviceScaleFactor: 3.5,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 6P": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 732
    },
    deviceScaleFactor: 3.5,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 6P landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 732,
      height: 412
    },
    deviceScaleFactor: 3.5,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 7": {
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 600,
      height: 960
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Nexus 7 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 960,
      height: 600
    },
    deviceScaleFactor: 2,
    isMobile: true,
    hasTouch: true
  },
  "Nokia Lumia 520": {
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 320,
      height: 533
    },
    deviceScaleFactor: 1.5,
    isMobile: true,
    hasTouch: true
  },
  "Nokia Lumia 520 landscape": {
    userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
    viewport: {
      width: 533,
      height: 320
    },
    deviceScaleFactor: 1.5,
    isMobile: true,
    hasTouch: true
  },
  "Nokia N9": {
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 480,
      height: 854
    },
    deviceScaleFactor: 1,
    isMobile: true,
    hasTouch: true
  },
  "Nokia N9 landscape": {
    userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
    viewport: {
      width: 854,
      height: 480
    },
    deviceScaleFactor: 1,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 2": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 731
    },
    deviceScaleFactor: 2.625,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 2 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 731,
      height: 411
    },
    deviceScaleFactor: 2.625,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 2 XL": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 411,
      height: 823
    },
    deviceScaleFactor: 3.5,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 2 XL landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 823,
      height: 411
    },
    deviceScaleFactor: 3.5,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 3": {
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 786
    },
    deviceScaleFactor: 2.75,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 3 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 786,
      height: 393
    },
    deviceScaleFactor: 2.75,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 4": {
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 353,
      height: 745
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 4 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 745,
      height: 353
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 4a(5G)": {
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 765
    },
    deviceScaleFactor: 2.63,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 4a(5G) landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 840,
      height: 312
    },
    deviceScaleFactor: 2.63,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 5": {
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 393,
      height: 727
    },
    deviceScaleFactor: 2.75,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 5 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 802,
      height: 293
    },
    deviceScaleFactor: 2.75,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 7": {
    userAgent: "Mozilla/5.0 (Linux; Android 14; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 412,
      height: 839
    },
    deviceScaleFactor: 2.625,
    isMobile: true,
    hasTouch: true
  },
  "Pixel 7 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 14; Pixel 7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 863,
      height: 360
    },
    deviceScaleFactor: 2.625,
    isMobile: true,
    hasTouch: true
  },
  "Moto G4": {
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 360,
      height: 640
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Moto G4 landscape": {
    userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Mobile Safari/537.36",
    viewport: {
      width: 640,
      height: 360
    },
    deviceScaleFactor: 3,
    isMobile: true,
    hasTouch: true
  },
  "Desktop Chrome HiDPI": {
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 1280,
      height: 720
    },
    deviceScaleFactor: 2,
    isMobile: false,
    hasTouch: false
  },
  "Desktop Edge HiDPI": {
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36 Edg/128.0.6613.18",
    viewport: {
      width: 1280,
      height: 720
    },
    deviceScaleFactor: 2,
    isMobile: false,
    hasTouch: false
  },
  "Desktop Firefox HiDPI": {
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0",
    viewport: {
      width: 1280,
      height: 720
    },
    deviceScaleFactor: 2,
    isMobile: false,
    hasTouch: false
  },
  "Desktop Safari": {
    userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.0 Safari/605.1.15",
    viewport: {
      width: 1280,
      height: 720
    },
    deviceScaleFactor: 2,
    isMobile: false,
    hasTouch: false
  },
  "Desktop Chrome": {
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36",
    viewport: {
      width: 1280,
      height: 720
    },
    deviceScaleFactor: 1,
    isMobile: false,
    hasTouch: false
  },
  "Desktop Edge": {
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.6613.18 Safari/537.36 Edg/128.0.6613.18",
    viewport: {
      width: 1280,
      height: 720
    },
    deviceScaleFactor: 1,
    isMobile: false,
    hasTouch: false
  },
  "Desktop Firefox": {
    userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:128.0) Gecko/20100101 Firefox/128.0",
    viewport: {
      width: 1280,
      height: 720
    },
    deviceScaleFactor: 1,
    isMobile: false,
    hasTouch: false
  }
};

// src/commands/browser/emulate.ts
function storeRestoreFunction(browser, scope, fn) {
  if (!restoreFunctions.has(browser)) {
    restoreFunctions.set(browser, /* @__PURE__ */ new Map());
  }
  const restoreFunctionsList = restoreFunctions.get(browser)?.get(scope);
  const updatedList = restoreFunctionsList ? [...restoreFunctionsList, fn] : [fn];
  restoreFunctions.get(browser)?.set(scope, updatedList);
}
async function emulate(scope, options) {
  if (!this.isBidi) {
    throw new Error("emulate command is only supported for Bidi");
  }
  if (scope === "geolocation") {
    if (!options) {
      throw new Error("Missing geolocation emulation options");
    }
    const patchedFn = options instanceof Error ? `cbError(new Error(${JSON.stringify(options.message)}))` : `cbSuccess({
                coords: ${JSON.stringify(options)},
                timestamp: Date.now()
            })`;
    const res = await this.scriptAddPreloadScript({
      functionDeclaration: (
        /*js*/
        `() => {
                Object.defineProperty(navigator.geolocation, 'getCurrentPosition', {
                    value: (cbSuccess, cbError) => ${patchedFn}
                })
            }`
      )
    });
    const resetFn = async () => this.scriptRemovePreloadScript({ script: res.script });
    storeRestoreFunction(this, "geolocation", resetFn);
    return resetFn;
  }
  if (scope === "userAgent") {
    if (typeof options !== "string") {
      throw new Error(`Expected userAgent emulation options to be a string, received ${typeof options}`);
    }
    const res = await this.scriptAddPreloadScript({
      functionDeclaration: (
        /*js*/
        `() => {
                Object.defineProperty(navigator, 'userAgent', {
                    value: ${JSON.stringify(options)}
                })
            }`
      )
    });
    const resetFn = async () => {
      return this.scriptRemovePreloadScript({ script: res.script });
    };
    storeRestoreFunction(this, "userAgent", resetFn);
    return resetFn;
  }
  if (scope === "clock") {
    const clock = new ClockManager(this);
    await clock.install(options);
    storeRestoreFunction(this, "clock", clock.restore.bind(clock));
    return clock;
  }
  if (scope === "colorScheme") {
    if (options !== "light" && options !== "dark") {
      throw new Error(`Expected "colorScheme" emulation options to be either "light" or "dark", received "${options}"`);
    }
    const res = await this.scriptAddPreloadScript({
      functionDeclaration: (
        /*js*/
        `() => {
                const originalMatchMedia = window.matchMedia
                Object.defineProperty(window, 'matchMedia', {
                    value: (query) => {
                        const colorSchemeQuery = query.match(/\\(prefers-color-scheme:(\\s)*(dark|light)\\)/i)
                        if (colorSchemeQuery) {
                            const result = originalMatchMedia(query)
                            Object.defineProperty(result, 'matches', {
                                value: colorSchemeQuery[2] === "${options}",
                                configurable: true
                            })
                            return result
                        }

                        return originalMatchMedia(query)
                    },
                    configurable: true
                })
            }`
      )
    });
    const resetFn = async () => this.scriptRemovePreloadScript({ script: res.script });
    storeRestoreFunction(this, "colorScheme", resetFn);
    return resetFn;
  }
  if (scope === "onLine") {
    if (typeof options !== "boolean") {
      throw new Error(`Expected "onLine" emulation options to be a boolean, received "${typeof options}"`);
    }
    const res = await this.scriptAddPreloadScript({
      functionDeclaration: (
        /*js*/
        `() => {
                Object.defineProperty(navigator, 'onLine', {
                    value: ${options}
                })
            }`
      )
    });
    const resetFn = async () => this.scriptRemovePreloadScript({ script: res.script });
    storeRestoreFunction(this, "onLine", resetFn);
    return resetFn;
  }
  if (scope === "device") {
    if (typeof options !== "string") {
      throw new Error(`Expected "device" emulation options to be a string, received "${typeof options}"`);
    }
    const device = deviceDescriptorsSource[options];
    if (!device) {
      throw new Error(`Unknown device name "${options}", please use one of the following: ${Object.keys(deviceDescriptorsSource).join(", ")}`);
    }
    const [restoreUserAgent] = await Promise.all([
      this.emulate("userAgent", device.userAgent),
      this.setViewport({
        ...device.viewport,
        devicePixelRatio: device.deviceScaleFactor
      })
    ]);
    const desktopViewport = deviceDescriptorsSource["Desktop Chrome"];
    const restoreFn = async () => Promise.all([
      restoreUserAgent(),
      this.setViewport({ ...desktopViewport.viewport, devicePixelRatio: desktopViewport.deviceScaleFactor })
    ]);
    return restoreFn;
  }
  throw new Error(`Invalid scope "${scope}", expected one of "geolocation", "userAgent", "colorScheme", "onLine", "device" or "clock"`);
}

// src/commands/browser/execute.ts
import { getBrowserObject as getBrowserObject2 } from "@wdio/utils";

// src/utils/bidi/value.ts
import { ELEMENT_KEY as ELEMENT_KEY7 } from "webdriver";
var TYPE_CONSTANT = "type";
var VALUE_CONSTANT = "value";
var LocalValue = class _LocalValue {
  type;
  value;
  constructor(type, value) {
    if (type === "undefined" /* Undefined */ || type === "null" /* Null */) {
      this.type = type;
    } else {
      this.type = type;
      this.value = value;
    }
  }
  /**
   * Creates a new LocalValue object with a string value.
   *
   * @param {string} value - The string value to be stored in the LocalValue object.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createStringValue(value) {
    return new _LocalValue("string" /* String */, value);
  }
  /**
   * Creates a new LocalValue object with a number value.
   *
   * @param {number} value - The number value.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createNumberValue(value) {
    return new _LocalValue("number" /* Number */, value);
  }
  /**
   * Creates a new LocalValue object with a special number value.
   *
   * @param {number} value - The value of the special number.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createSpecialNumberValue(value) {
    if (Number.isNaN(value)) {
      return new _LocalValue("number" /* SpecialNumber */, "NaN");
    }
    if (Object.is(value, -0)) {
      return new _LocalValue("number" /* SpecialNumber */, "-0");
    }
    if (value === Infinity) {
      return new _LocalValue("number" /* SpecialNumber */, "Infinity");
    }
    if (value === -Infinity) {
      return new _LocalValue("number" /* SpecialNumber */, "-Infinity");
    }
    return new _LocalValue("number" /* SpecialNumber */, value);
  }
  /**
   * Creates a new LocalValue object with an undefined value.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createUndefinedValue() {
    return new _LocalValue("undefined" /* Undefined */);
  }
  /**
   * Creates a new LocalValue object with a null value.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createNullValue() {
    return new _LocalValue("null" /* Null */);
  }
  /**
   * Creates a new LocalValue object with a boolean value.
   *
   * @param {boolean} value - The boolean value.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createBooleanValue(value) {
    return new _LocalValue("boolean" /* Boolean */, value);
  }
  /**
   * Creates a new LocalValue object with a BigInt value.
   *
   * @param {BigInt} value - The BigInt value.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createBigIntValue(value) {
    return new _LocalValue("bigint" /* BigInt */, value);
  }
  /**
   * Creates a new LocalValue object with an array.
   *
   * @param {Array} value - The array.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createArrayValue(value) {
    return new _LocalValue("array" /* Array */, value);
  }
  /**
   * Creates a new LocalValue object with date value.
   *
   * @param {string} value - The date.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createDateValue(value) {
    return new _LocalValue("date" /* Date */, value);
  }
  /**
   * Creates a new LocalValue object of map value.
   * @param {Map} map - The map.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createMapValue(map) {
    const value = [];
    Object.entries(map).forEach((entry) => {
      value.push(entry);
    });
    return new _LocalValue("map" /* Map */, value);
  }
  /**
   * Creates a new LocalValue object from the passed object.
   *
   * @param {Object} map - The object.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createObjectValue(object) {
    const value = [];
    Object.entries(object).forEach(([key, val]) => {
      value.push([key, _LocalValue.getArgument(val)]);
    });
    return new _LocalValue("object" /* Object */, value);
  }
  /**
   * Creates a new LocalValue object of regular expression value.
   *
   * @param {string} value - The value of the regular expression.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createRegularExpressionValue(value) {
    return new _LocalValue("regexp" /* RegularExpression */, value);
  }
  /**
   * Creates a new LocalValue object with the specified value.
   * @param {Set} value - The value to be set.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createSetValue(value) {
    return new _LocalValue("set" /* Set */, value);
  }
  /**
   * Creates a new LocalValue object with the given channel value
   *
   * @param {ChannelValue} value - The channel value.
   * @returns {LocalValue} - The created LocalValue object.
   */
  static createChannelValue(value) {
    return new _LocalValue("channel" /* Channel */, value);
  }
  static createReferenceValue(handle, sharedId) {
    return new ReferenceValue(handle, sharedId);
  }
  static getArgument(argument) {
    const type = typeof argument;
    switch (type) {
      case "string" /* String */:
        return _LocalValue.createStringValue(argument);
      case "number" /* Number */:
        if (Number.isNaN(argument) || Object.is(argument, -0) || !Number.isFinite(argument)) {
          return _LocalValue.createSpecialNumberValue(argument);
        }
        return _LocalValue.createNumberValue(argument);
      case "boolean" /* Boolean */:
        return _LocalValue.createBooleanValue(argument);
      case "bigint" /* BigInt */:
        return _LocalValue.createBigIntValue(argument.toString());
      case "undefined" /* Undefined */:
        return _LocalValue.createUndefinedValue();
      case "object" /* Object */:
        if (argument === null) {
          return _LocalValue.createNullValue();
        }
        if (argument instanceof Date) {
          return _LocalValue.createDateValue(argument);
        }
        if (argument instanceof Map) {
          const map = [];
          argument.forEach((value, key) => {
            const objectKey = typeof key === "string" ? key : _LocalValue.getArgument(key);
            const objectValue = _LocalValue.getArgument(value);
            map.push([objectKey, objectValue]);
          });
          return new _LocalValue("map" /* Map */, map);
        }
        if (argument instanceof Set) {
          const set = [];
          argument.forEach((value) => {
            set.push(_LocalValue.getArgument(value));
          });
          return _LocalValue.createSetValue(set);
        }
        if (argument instanceof Array) {
          const arr = [];
          argument.forEach((value) => {
            arr.push(_LocalValue.getArgument(value));
          });
          return _LocalValue.createArrayValue(arr);
        }
        if (argument instanceof RegExp) {
          return _LocalValue.createRegularExpressionValue({
            pattern: argument.source,
            flags: argument.flags
          });
        }
        if (ELEMENT_KEY7 in argument) {
          return _LocalValue.createReferenceValue(
            "sharedId" /* SharedId */,
            argument[ELEMENT_KEY7]
          );
        }
        return _LocalValue.createObjectValue(argument);
    }
    throw new Error(`Unsupported type: ${type}`);
  }
  asMap() {
    return {
      [TYPE_CONSTANT]: this.type,
      ...!(this.type === "null" /* Null */ || this.type === "undefined" /* Undefined */) ? { [VALUE_CONSTANT]: this.value } : {}
    };
  }
};
var ReferenceValue = class {
  handle;
  sharedId;
  /**
   * Constructs a new ReferenceValue object.
   * @param {string} handle - The handle value.
   * @param {string} sharedId - The shared ID value.
   */
  constructor(handle, sharedId) {
    if (handle === "handle" /* Handle */) {
      this.handle = sharedId;
    } else if (handle === "sharedId" /* SharedId */) {
      this.sharedId = sharedId;
    } else {
      this.handle = handle;
      this.sharedId = sharedId;
    }
  }
  asMap() {
    const toReturn = {};
    if (typeof this.handle !== "undefined") {
      toReturn["handle" /* Handle */] = this.handle;
    }
    if (typeof this.sharedId !== "undefined") {
      toReturn["sharedId" /* SharedId */] = this.sharedId;
    }
    return toReturn;
  }
};

// src/context.ts
import logger4 from "@wdio/logger";
var contextManager = /* @__PURE__ */ new Map();
var log4 = logger4("webdriverio:ContextManager");
function getContextManager(browser) {
  const existingContextManager = contextManager.get(browser);
  if (existingContextManager) {
    return existingContextManager;
  }
  const newContext = new ContextManager(browser);
  contextManager.set(browser, newContext);
  return newContext;
}
var ContextManager = class {
  #browser;
  #initialize;
  #currentContext;
  constructor(browser) {
    this.#browser = browser;
    if (!browser.isBidi || process.env.VITEST_WORKER_ID || browser.options?.automationProtocol !== "webdriver") {
      this.#initialize = Promise.resolve(true);
      return;
    }
    this.#initialize = this.#browser.sessionSubscribe({
      events: ["browsingContext.navigationStarted"]
    }).then(() => true, () => false);
    this.#browser.on("browsingContext.navigationStarted", this.#handleNavigationStarted.bind(this));
  }
  async initialize() {
    return this.#initialize;
  }
  /**
   * We use this handler to observe the current context which is used to navigate to a certain url.
   * This is most likely the context that the user is using. However if a frame was loaded on the page
   * then this handler is triggered with the context of the frame. To find out which context we are in
   * we use the `getWindowHandle` method to validate our assumption before setting the `#currentContext`
   * value.
   *
   * @param {local.BrowsingContextNavigationInfo} context  browsing context used to navigate
   */
  #handleNavigationStarted(context) {
    this.#browser.getWindowHandle().then((windowHandle) => {
      if (context.context === windowHandle) {
        log4.info(`Update current context: ${context.context}`);
        this.#currentContext = context.context;
      }
    });
  }
  async getCurrentContext() {
    if (!this.#currentContext) {
      this.#currentContext = await this.#browser.getWindowHandle();
    }
    return this.#currentContext;
  }
};

// src/commands/browser/execute.ts
async function execute(script, ...args) {
  if (typeof script !== "string" && typeof script !== "function") {
    throw new Error("number or type of arguments don't agree with execute protocol command");
  }
  if (this.isBidi && !this.isMultiremote) {
    const browser = getBrowserObject2(this);
    const contextManager2 = getContextManager(browser);
    const context = await contextManager2.getCurrentContext();
    const result = await browser.scriptCallFunction({
      functionDeclaration: script.toString(),
      awaitPromise: false,
      arguments: args.map((arg) => LocalValue.getArgument(arg)),
      target: {
        context
      }
    });
    return parseScriptResult(result);
  }
  if (typeof script === "function") {
    script = `return (${script}).apply(null, arguments)`;
  }
  return this.executeScript(script, verifyArgsAndStripIfElement(args));
}

// src/commands/browser/executeAsync.ts
import { getBrowserObject as getBrowserObject3 } from "@wdio/utils";
async function executeAsync(script, ...args) {
  if (typeof script !== "string" && typeof script !== "function") {
    throw new Error("number or type of arguments don't agree with execute protocol command");
  }
  if (this.isBidi && !this.isMultiremote) {
    const browser = getBrowserObject3(this);
    const contextManager2 = getContextManager(browser);
    const context = await contextManager2.getCurrentContext();
    const functionDeclaration = `function (...args) {
            return new Promise(async (resolve, reject) => {
                try {
                    await ${script.toString()}.call(this, ...args, resolve)
                } catch (err) {
                    return reject(err)
                }
            })
        }`;
    const result = await browser.scriptCallFunction({
      functionDeclaration,
      awaitPromise: true,
      arguments: args.map((arg) => LocalValue.getArgument(arg)),
      target: {
        context
      }
    });
    return parseScriptResult(result);
  }
  if (typeof script === "function") {
    script = `return (${script}).apply(null, arguments)`;
  }
  return this.executeAsyncScript(script, verifyArgsAndStripIfElement(args));
}

// src/commands/browser/getCookies.ts
async function getCookies(names) {
  if (names === void 0) {
    return this.getAllCookies();
  }
  const namesList = Array.isArray(names) ? names : [names];
  if (namesList.every((obj) => typeof obj !== "string")) {
    throw new Error("Invalid input (see https://webdriver.io/docs/api/browser/getCookies for documentation)");
  }
  const allCookies = await this.getAllCookies();
  return allCookies.filter((cookie) => namesList.includes(cookie.name));
}

// src/commands/browser/getPuppeteer.ts
import logger5 from "@wdio/logger";
import { userImport } from "@wdio/utils";
var log5 = logger5("webdriverio");
async function getPuppeteer() {
  const puppeteer = await userImport("puppeteer-core");
  if (!puppeteer) {
    throw new Error(
      'You need to install "puppeteer-core" package as a dependency in order to use the "getPuppeteer" method'
    );
  }
  if (this.puppeteer?.connected) {
    log5.debug("Reusing existing puppeteer session");
    return this.puppeteer;
  }
  const { headers } = this.options;
  const cdpEndpoint = this.capabilities["se:cdp"];
  if (cdpEndpoint) {
    this.puppeteer = await puppeteer.connect({
      browserWSEndpoint: cdpEndpoint,
      defaultViewport: null,
      headers
    });
    return this.puppeteer;
  }
  const requestedCapabilities = this.requestedCapabilities?.alwaysMatch || this.requestedCapabilities;
  const isAerokubeSession = requestedCapabilities["selenoid:options"] || requestedCapabilities["moon:options"];
  if (isAerokubeSession) {
    const { hostname, port } = this.options;
    this.puppeteer = await puppeteer.connect({
      browserWSEndpoint: `ws://${hostname}:${port}/devtools/${this.sessionId}`,
      defaultViewport: null,
      headers
    });
    return this.puppeteer;
  }
  const chromiumOptions = this.capabilities["goog:chromeOptions"] || this.capabilities["ms:edgeOptions"];
  if (chromiumOptions && chromiumOptions.debuggerAddress) {
    this.puppeteer = await puppeteer.connect({
      browserURL: `http://${chromiumOptions.debuggerAddress.replace("localhost", "0.0.0.0")}`,
      defaultViewport: null
    });
    return this.puppeteer;
  }
  if (this.capabilities.browserName?.toLowerCase() === "firefox") {
    if (!this.capabilities.browserVersion) {
      throw new Error(`Can't find "browserVersion" in capabilities`);
    }
    const majorVersion = parseInt(this.capabilities.browserVersion.split(".").shift() || "", 10);
    if (majorVersion >= 79) {
      const reqCaps = this.requestedCapabilities.alwaysMatch || this.requestedCapabilities;
      let browserURL;
      if (this.capabilities["moz:debuggerAddress"]) {
        browserURL = this.capabilities["moz:debuggerAddress"];
      } else {
        const ffOptions = this.capabilities["moz:firefoxOptions"];
        const ffArgs = reqCaps["moz:firefoxOptions"]?.args || [];
        const rdPort = ffOptions && ffOptions.debuggerAddress ? ffOptions.debuggerAddress : ffArgs[ffArgs.findIndex((arg) => arg === FF_REMOTE_DEBUG_ARG) + 1];
        if (rdPort) {
          browserURL = `http://localhost:${rdPort}`;
        }
      }
      if (!browserURL) {
        throw new Error(
          'Could\'t find a websocket url within returned capabilities to connect to! Make sure you have "moz:debuggerAddress" set to `true` in your Firefox capabilities'
        );
      }
      this.puppeteer = await puppeteer.connect({
        browserURL,
        defaultViewport: null
      });
      return this.puppeteer;
    }
  }
  throw new Error(
    "Using DevTools capabilities is not supported for this session. This feature is only supported for local testing on Chrome, Firefox and Chromium Edge."
  );
}

// src/commands/browser/getWindowSize.ts
import { getBrowserObject as getBrowserObject4 } from "@wdio/utils";
async function getWindowSize() {
  const browser = getBrowserObject4(this);
  const { width, height } = await browser.getWindowRect();
  return { width, height };
}

// src/commands/browser/keys.ts
async function keys(value) {
  let keySequence = [];
  if (typeof value === "string") {
    keySequence = checkUnicode(value);
  } else if (Array.isArray(value)) {
    const charArray = value;
    for (const charSet of charArray) {
      keySequence = keySequence.concat(checkUnicode(charSet));
    }
  } else {
    throw new Error('"keys" command requires a string or array of strings as parameter');
  }
  const keyAction = this.action("key");
  keySequence.forEach((value2) => keyAction.down(value2));
  if (!this.isIOS) {
    keyAction.pause(10);
  }
  keySequence.forEach((value2) => keyAction.up(value2));
  return keyAction.perform(true);
}

// src/commands/browser/mock.ts
import { getBrowserObject as getBrowserObject5 } from "@wdio/utils";

// src/utils/interception/index.ts
import EventEmitter2 from "node:events";
import logger6 from "@wdio/logger";
import { URLPattern } from "urlpattern-polyfill";

// src/utils/Timer.ts
var TIMEOUT_ERROR = "timeout";
var NOOP = () => {
};
var Timer = class {
  constructor(_delay, _timeout, _fn, _leading = false) {
    this._delay = _delay;
    this._timeout = _timeout;
    this._fn = _fn;
    this._leading = _leading;
    const retPromise = new Promise((resolve5, reject) => {
      this._resolve = resolve5;
      this._reject = reject;
    });
    this._start();
    return retPromise;
  }
  _conditionExecutedCnt = 0;
  _resolve = NOOP;
  _reject = NOOP;
  _startTime;
  _ticks = 0;
  _timeoutId;
  _mainTimeoutId;
  _lastError;
  _start() {
    this._startTime = Date.now();
    if (this._leading) {
      this._tick();
    } else {
      this._timeoutId = setTimeout(this._tick.bind(this), this._delay);
    }
    this._mainTimeoutId = setTimeout(() => {
      if (!this._wasConditionExecuted()) {
        return;
      }
      const reason = this._lastError || new Error(TIMEOUT_ERROR);
      this._reject(reason);
      this._stop();
    }, this._timeout);
  }
  _stop() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
    delete this._timeoutId;
  }
  _stopMain() {
    if (this._mainTimeoutId) {
      clearTimeout(this._mainTimeoutId);
    }
  }
  _tick() {
    const result = this._fn();
    if (typeof result.then !== "function") {
      if (!result) {
        return this._checkCondition(new Error(TIMEOUT_ERROR));
      }
      return this._checkCondition(void 0, result);
    }
    result.then(
      (res) => this._checkCondition(void 0, res),
      (err) => this._checkCondition(err)
    );
  }
  _checkCondition(err, res) {
    ++this._conditionExecutedCnt;
    this._lastError = err;
    if (res) {
      this._resolve(res);
      this._stop();
      this._stopMain();
      return;
    }
    const diff = Date.now() - (this._startTime || 0) - this._ticks++ * this._delay;
    const delay = Math.max(0, this._delay - diff);
    this._stop();
    if (this._hasTime(delay)) {
      this._timeoutId = setTimeout(this._tick.bind(this), delay);
    } else {
      this._stopMain();
      const reason = this._lastError || new Error(TIMEOUT_ERROR);
      this._reject(reason);
    }
  }
  _hasTime(delay) {
    return Date.now() - (this._startTime || 0) + delay <= this._timeout;
  }
  _wasConditionExecuted() {
    return this._conditionExecutedCnt > 0;
  }
};
var Timer_default = Timer;

// src/utils/interception/utils.ts
function parseOverwrite(overwrite, request) {
  const result = {};
  if ("body" in overwrite && overwrite.body) {
    const bodyOverwrite = typeof overwrite.body === "function" ? overwrite.body(request) : overwrite.body;
    result.body = typeof bodyOverwrite === "string" ? (
      /**
       * if body is a string we can pass it as is
       */
      {
        type: "string",
        value: bodyOverwrite
      }
    ) : (
      /**
       * if body is an object we need to encode it
       */
      {
        type: "base64",
        value: globalThis.Buffer ? globalThis.Buffer.from(JSON.stringify(bodyOverwrite || "")).toString("base64") : btoa(JSON.stringify(bodyOverwrite))
      }
    );
  }
  if ("headers" in overwrite) {
    const headersOverwrite = typeof overwrite.headers === "function" ? overwrite.headers(request) : overwrite.headers;
    result.headers = Object.entries(headersOverwrite || {}).map(([name, value]) => ({
      name,
      value: { type: "string", value }
    }));
  }
  if ("cookies" in overwrite && overwrite.cookies) {
    const cookieOverwrite = typeof overwrite.cookies === "function" ? overwrite.cookies(request) || [] : overwrite.cookies;
    result.cookies = cookieOverwrite.map((cookie) => ({
      name: cookie.name,
      value: {
        type: "string",
        value: cookie.value
      },
      domain: cookie.domain,
      path: cookie.path,
      expires: cookie.expiry,
      httpOnly: cookie.httpOnly,
      secure: cookie.secure,
      sameSite: cookie.sameSite?.toLowerCase()
    }));
  }
  if ("statusCode" in overwrite && overwrite.statusCode) {
    const statusCodeOverwrite = typeof overwrite.statusCode === "function" ? overwrite.statusCode(request) : overwrite.statusCode;
    result.statusCode = statusCodeOverwrite;
  }
  if ("method" in overwrite) {
    result.method = typeof overwrite.method === "function" ? overwrite.method(request) : overwrite.method;
  }
  if ("url" in overwrite) {
    result.url = typeof overwrite.url === "function" ? overwrite.url(request) : overwrite.url;
  }
  return result;
}
function getPatternParam(pattern, key) {
  if (key !== "pathname" && pattern[key] === "*") {
    return;
  }
  if (key === "port" && pattern.port === "") {
    return pattern.protocol === "https" ? "443" : "80";
  }
  return pattern[key].replaceAll("*", "\\*");
}

// src/utils/interception/index.ts
var log6 = logger6("WebDriverInterception");
var hasSubscribedToEvents = false;
var WebDriverInterception = class _WebDriverInterception {
  #pattern;
  #mockId;
  #filterOptions;
  #browser;
  #emitter = new EventEmitter2();
  #restored = false;
  #requestOverwrites = [];
  #respondOverwrites = [];
  #calls = [];
  constructor(pattern, mockId, filterOptions, browser) {
    this.#pattern = pattern;
    this.#mockId = mockId;
    this.#filterOptions = filterOptions;
    this.#browser = browser;
    browser.on("network.beforeRequestSent", this.#handleBeforeRequestSent.bind(this));
    browser.on("network.responseStarted", this.#handleResponseStarted.bind(this));
  }
  static async initiate(url6, filterOptions, browser) {
    const pattern = parseUrlPattern(url6);
    if (!hasSubscribedToEvents) {
      await browser.sessionSubscribe({
        events: [
          "network.beforeRequestSent",
          "network.responseStarted"
        ]
      });
      log6.info("subscribed to network events");
      hasSubscribedToEvents = true;
    }
    const interception = await browser.networkAddIntercept({
      phases: ["beforeRequestSent", "responseStarted"],
      urlPatterns: [{
        type: "pattern",
        protocol: getPatternParam(pattern, "protocol"),
        hostname: getPatternParam(pattern, "hostname"),
        pathname: getPatternParam(pattern, "pathname"),
        port: getPatternParam(pattern, "port"),
        search: getPatternParam(pattern, "search")
      }]
    });
    return new _WebDriverInterception(pattern, interception.intercept, filterOptions, browser);
  }
  #handleBeforeRequestSent(request) {
    if (!this.#isRequestMatching(request)) {
      return;
    }
    if (!this.#matchesFilterOptions(request)) {
      return this.#browser.networkContinueRequest({
        request: request.request.request
      });
    }
    this.#emitter.emit("request", request);
    const hasRequestOverwrites = this.#requestOverwrites.length > 0;
    if (hasRequestOverwrites) {
      const { overwrite, abort } = this.#requestOverwrites[0].once ? this.#requestOverwrites.shift() || {} : this.#requestOverwrites[0];
      if (abort) {
        this.#emitter.emit("fail", request.request.request);
        return this.#browser.networkFailRequest({ request: request.request.request });
      }
      this.#emitter.emit("overwrite", request);
      return this.#browser.networkContinueRequest({
        request: request.request.request,
        ...overwrite ? parseOverwrite(overwrite, request) : {}
      });
    }
    this.#emitter.emit("continue", request.request.request);
    return this.#browser.networkContinueRequest({
      request: request.request.request
    });
  }
  #handleResponseStarted(request) {
    if (!this.#isRequestMatching(request)) {
      return;
    }
    const continueRequest = (
      /**
       * - mock has no request/respond overwrites
       * - no request modifications are set, e.g. no overwrite is set
       */
      !this.#matchesFilterOptions(request) || this.#respondOverwrites.length === 0 || !this.#respondOverwrites[0].overwrite
    );
    if (continueRequest) {
      this.#emitter.emit("continue", request.request.request);
      return this.#browser.networkProvideResponse({
        request: request.request.request
      }).catch(this.#handleNetworkProvideResponseError);
    }
    this.#calls.push(request);
    const { overwrite } = this.#respondOverwrites[0].once ? this.#respondOverwrites.shift() || {} : this.#respondOverwrites[0];
    if (overwrite) {
      this.#emitter.emit("overwrite", request);
      return this.#browser.networkProvideResponse({
        request: request.request.request,
        ...parseOverwrite(overwrite, request)
      }).catch(this.#handleNetworkProvideResponseError);
    }
    this.#emitter.emit("continue", request.request.request);
    return this.#browser.networkProvideResponse({
      request: request.request.request
    }).catch(this.#handleNetworkProvideResponseError);
  }
  /**
   * It appears that the networkProvideResponse method may throw an "no such request" error even though the request
   * is marked as "blocked", in these cases we can safely ignore the error.
   * @param err Bidi message error
   */
  #handleNetworkProvideResponseError(err) {
    if (err.message.endsWith("no such request")) {
      return;
    }
    throw err;
  }
  #isRequestMatching(request) {
    return request.isBlocked && this.#pattern && this.#pattern.test(request.request.url);
  }
  #matchesFilterOptions(request) {
    let isRequestMatching = true;
    if (this.#filterOptions.method) {
      isRequestMatching = typeof this.#filterOptions.method === "function" ? this.#filterOptions.method(request.request.method) : this.#filterOptions.method === request.request.method;
    }
    if (this.#filterOptions.requestHeaders) {
      isRequestMatching = typeof this.#filterOptions.requestHeaders === "function" ? this.#filterOptions.requestHeaders(request.request.headers.reduce((acc, { name, value }) => {
        acc[name] = value.type === "string" ? value.value : Buffer.from(value.value, "base64").toString();
        return acc;
      }, {})) : Object.entries(this.#filterOptions.requestHeaders).every(([key, value]) => {
        const header = request.request.headers.find(({ name }) => name === key);
        if (!header) {
          return false;
        }
        return header.value.type === "string" ? header.value.value === value : Buffer.from(header.value.value, "base64").toString() === value;
      });
    }
    if (this.#filterOptions.responseHeaders && "response" in request) {
      isRequestMatching = typeof this.#filterOptions.responseHeaders === "function" ? this.#filterOptions.responseHeaders(request.response.headers.reduce((acc, { name, value }) => {
        acc[name] = value.type === "string" ? value.value : Buffer.from(value.value, "base64").toString();
        return acc;
      }, {})) : Object.entries(this.#filterOptions.responseHeaders).every(([key, value]) => {
        const header = request.response.headers.find(({ name }) => name === key);
        if (!header) {
          return false;
        }
        return header.value.type === "string" ? header.value.value === value : Buffer.from(header.value.value, "base64").toString() === value;
      });
    }
    if (this.#filterOptions.statusCode && "response" in request) {
      isRequestMatching = typeof this.#filterOptions.statusCode === "function" ? this.#filterOptions.statusCode(request.response.status) : this.#filterOptions.statusCode === request.response.status;
    }
    return isRequestMatching;
  }
  #setOverwrite = (overwriteProp, { overwrite, abort, once }) => {
    return once ? [
      ...overwriteProp.filter(({ once: once2 }) => once2),
      { overwrite, abort, once }
    ] : [{ overwrite, abort }];
  };
  /**
   * allows access to all requests made with given pattern
   */
  get calls() {
    return this.#calls;
  }
  /**
   * Resets all information stored in the `mock.calls` set.
   */
  clear() {
    this.#calls = [];
    return this;
  }
  /**
   * Does what `mock.clear()` does and makes removes custom request overrides
   * and response overwrites
   */
  reset() {
    this.clear();
    this.#respondOverwrites = [];
    this.#requestOverwrites = [];
    return this;
  }
  /**
   * Does everything that `mock.reset()` does, and also
   * removes any mocked return values or implementations.
   * Restored mock does not emit events and could not mock responses
   */
  async restore() {
    this.reset();
    this.#respondOverwrites = [];
    this.#restored = true;
    const handle = await this.#browser.getWindowHandle();
    log6.trace(`Restoring mock for ${handle}`);
    SESSION_MOCKS[handle].delete(this);
    if (this.#mockId) {
      await this.#browser.networkRemoveIntercept({ intercept: this.#mockId });
    }
    return this;
  }
  /**
   * Always use request modification for the next request done by the browser.
   * @param payload  payload to overwrite the request
   * @param once     apply overwrite only once for the next request
   * @returns        this instance to chain commands
   */
  request(overwrite, once) {
    this.#ensureNotRestored();
    this.#requestOverwrites = this.#setOverwrite(this.#requestOverwrites, { overwrite, once });
    return this;
  }
  /**
   * alias for `mock.request(, true)`
   */
  requestOnce(payload) {
    return this.request(payload, true);
  }
  /**
   * Always respond with same overwrite
   * @param {*}       payload  payload to overwrite the response
   * @param {*}       params   additional respond parameters to overwrite
   * @param {boolean} once     apply overwrite only once for the next request
   * @returns                  this instance to chain commands
   */
  respond(payload, params = {}, once) {
    this.#ensureNotRestored();
    const body = typeof payload === "string" ? payload : globalThis.Buffer && globalThis.Buffer.isBuffer(payload) ? payload.toString("base64") : JSON.stringify(payload);
    const overwrite = { body, ...params };
    this.#respondOverwrites = this.#setOverwrite(this.#respondOverwrites, { overwrite, once });
    return this;
  }
  /**
   * alias for `mock.respond(, true)`
   */
  respondOnce(payload, params = {}) {
    return this.respond(payload, params, true);
  }
  /**
   * Abort the request with an error code
   * @param {string} errorReason  error code of the response
   * @param {boolean} once        if request should be aborted only once for the next request
   */
  abort(once) {
    this.#ensureNotRestored();
    this.#requestOverwrites = this.#setOverwrite(this.#requestOverwrites, { abort: true, once });
    return this;
  }
  /**
   * alias for `mock.abort(true)`
   */
  abortOnce() {
    return this.abort(true);
  }
  /**
   * Redirect request to another URL
   * @param {string} redirectUrl  URL to redirect to
   * @param {boolean} sticky      if request should be redirected for all following requests
   */
  redirect(redirectUrl, once) {
    this.#ensureNotRestored();
    const requestWith = { url: redirectUrl };
    this.request(requestWith, once);
    return this;
  }
  /**
   * alias for `mock.redirect(, true)`
   */
  redirectOnce(redirectUrl) {
    return this.redirect(redirectUrl, true);
  }
  on(event, callback) {
    this.#emitter.on(event, callback);
    return this;
  }
  #ensureNotRestored() {
    if (this.#restored) {
      throw new Error("This can't be done on restored mock");
    }
  }
  waitForResponse({
    timeout = this.#browser.options.waitforTimeout,
    interval = this.#browser.options.waitforInterval,
    timeoutMsg
  } = {}) {
    if (typeof timeout !== "number") {
      timeout = this.#browser.options.waitforTimeout;
    }
    if (typeof interval !== "number") {
      interval = this.#browser.options.waitforInterval;
    }
    const fn = async () => this.calls && (await this.calls).length > 0;
    const timer = new Timer_default(interval, timeout, fn, true);
    return this.#browser.call(() => timer.catch((e) => {
      if (e.message === "timeout") {
        if (typeof timeoutMsg === "string") {
          throw new Error(timeoutMsg);
        }
        throw new Error(`waitForResponse timed out after ${timeout}ms`);
      }
      throw new Error(`waitForResponse failed with the following reason: ${e && e.message || e}`);
    }));
  }
};
function parseUrlPattern(url6) {
  if (typeof url6 === "object") {
    return url6;
  }
  if (url6.startsWith("http")) {
    return new URLPattern(url6);
  }
  return new URLPattern({
    pathname: url6
  });
}

// src/commands/browser/mock.ts
var SESSION_MOCKS = {};
async function mock(url6, filterOptions) {
  if (!this.isBidi) {
    throw new Error("Mocking is only supported when running tests using WebDriver Bidi");
  }
  const browser = getBrowserObject5(this);
  const contextManager2 = getContextManager(browser);
  const context = await contextManager2.getCurrentContext();
  if (!SESSION_MOCKS[context]) {
    SESSION_MOCKS[context] = /* @__PURE__ */ new Set();
  }
  const networkInterception = await WebDriverInterception.initiate(url6, filterOptions || {}, this);
  SESSION_MOCKS[context].add(networkInterception);
  return networkInterception;
}

// src/commands/browser/mockClearAll.ts
import logger7 from "@wdio/logger";
var log7 = logger7("webdriverio:mockClearAll");
async function mockClearAll() {
  for (const [handle, mocks] of Object.entries(SESSION_MOCKS)) {
    log7.trace(`Clearing mocks for ${handle}`);
    for (const mock2 of mocks) {
      mock2.clear();
    }
  }
}

// src/commands/browser/mockRestoreAll.ts
import logger8 from "@wdio/logger";
var log8 = logger8("webdriverio:mockRestoreAll");
async function mockRestoreAll() {
  for (const [handle, mocks] of Object.entries(SESSION_MOCKS)) {
    log8.trace(`Clearing mocks for ${handle}`);
    for (const mock2 of mocks) {
      await mock2.restore();
    }
  }
}

// src/commands/browser/newWindow.ts
import { sleep } from "@wdio/utils";
import newWindowHelper from "./scripts/newWindow.js";
var WAIT_FOR_NEW_HANDLE_TIMEOUT = 3e3;
async function newWindow(url6, { windowName = "", windowFeatures = "" } = {}) {
  if (typeof url6 !== "string") {
    throw new Error("number or type of arguments don't agree with newWindow command");
  }
  if (this.isMobile) {
    throw new Error("newWindow command is not supported on mobile platforms");
  }
  const tabsBefore = await this.getWindowHandles();
  if (this.isBidi) {
    const { context } = await this.browsingContextCreate({ type: "window" });
    await this.browsingContextNavigate({ context, url: url6 });
  } else {
    await this.execute(newWindowHelper, url6, windowName, windowFeatures);
  }
  let tabsAfter = await this.getWindowHandles();
  const now = Date.now();
  while (Date.now() - now < WAIT_FOR_NEW_HANDLE_TIMEOUT) {
    tabsAfter = await this.getWindowHandles();
    if (tabsAfter.length > tabsBefore.length) {
      break;
    }
    await sleep(100);
  }
  const newTab = tabsAfter.pop();
  if (!newTab) {
    throw new Error("No window handle was found to switch to");
  }
  await this.switchToWindow(newTab);
  return newTab;
}

// src/commands/browser/pause.ts
function pause(milliseconds = 1e3) {
  return new Promise((resolve5) => setTimeout(resolve5, milliseconds));
}

// src/commands/browser/react$$.ts
import fs2 from "node:fs/promises";
import url from "node:url";
import { resolve } from "import-meta-resolve";
import { waitToLoadReact, react$$ as react$$Script } from "./scripts/resq.js";
var resqScript;
async function react$$(selector, { props = {}, state = {} } = {}) {
  if (!resqScript) {
    const resqScriptPath = url.fileURLToPath(await resolve("resq", import.meta.url));
    resqScript = (await fs2.readFile(resqScriptPath)).toString();
  }
  await this.executeScript(resqScript, []);
  await this.execute(waitToLoadReact);
  const res = await this.execute(
    react$$Script,
    selector,
    props,
    state
  );
  const elements = await getElements.call(this, selector, res, { isReactElement: true });
  return enhanceElementsArray(elements, this, selector, "react$$", [props, state]);
}

// src/commands/browser/react$.ts
import fs3 from "node:fs/promises";
import url2 from "node:url";
import { resolve as resolve2 } from "import-meta-resolve";
import { waitToLoadReact as waitToLoadReact2, react$ as react$Script } from "./scripts/resq.js";
var resqScript2;
async function react$(selector, { props = {}, state = {} } = {}) {
  if (!resqScript2) {
    const resqScriptPath = url2.fileURLToPath(await resolve2("resq", import.meta.url));
    resqScript2 = (await fs3.readFile(resqScriptPath)).toString();
  }
  await this.executeScript(resqScript2.toString(), []);
  await this.execute(waitToLoadReact2);
  const res = await this.execute(
    react$Script,
    selector,
    props,
    state
  );
  return getElement.call(this, selector, res, { isReactElement: true });
}

// src/commands/browser/reloadSession.ts
import logger9 from "@wdio/logger";
var log9 = logger9("webdriverio");
async function reloadSession(newCapabilities) {
  const oldSessionId = this.sessionId;
  const shutdownDriver = Boolean(newCapabilities?.browserName);
  try {
    await this.deleteSession({ shutdownDriver });
  } catch (err) {
    log9.warn(`Suppressing error closing the session: ${err.stack}`);
  }
  if (this.puppeteer?.connected) {
    this.puppeteer.disconnect();
    log9.debug("Disconnected puppeteer session");
  }
  const ProtocolDriver = (await import(
    /* @vite-ignore */
    this.options.automationProtocol
  )).default;
  await ProtocolDriver.reloadSession(this, newCapabilities);
  const options = this.options;
  if (Array.isArray(options.onReload) && options.onReload.length) {
    await Promise.all(options.onReload.map((hook) => hook(oldSessionId, this.sessionId)));
  }
  return this.sessionId;
}

// src/commands/browser/restore.ts
async function restore(scopes2) {
  const scopeArray = !scopes2 || Array.isArray(scopes2) ? scopes2 : [scopes2];
  const instanceRestoreFunctions = restoreFunctions.get(this);
  if (!instanceRestoreFunctions) {
    return;
  }
  await Promise.all(Array.from(instanceRestoreFunctions.entries()).map(async ([scope, restoreFunctionsList]) => {
    if (!scopeArray || scopeArray.includes(scope)) {
      await Promise.all(restoreFunctionsList.map((fn) => fn()));
      instanceRestoreFunctions.set(scope, []);
    }
  }));
}

// src/commands/browser/savePDF.ts
import fs4 from "node:fs";
async function savePDF(filepath, options) {
  if (typeof filepath !== "string" || !filepath.endsWith(".pdf")) {
    throw new Error('savePDF expects a filepath of type string and ".pdf" file ending');
  }
  const absoluteFilepath = getAbsoluteFilepath(filepath);
  await assertDirectoryExists(absoluteFilepath);
  const pdf = await this.printPage(
    options?.orientation,
    options?.scale,
    options?.background,
    options?.width,
    options?.height,
    options?.top,
    options?.bottom,
    options?.left,
    options?.right,
    options?.shrinkToFit,
    options?.pageRanges
  );
  const page = Buffer.from(pdf, "base64");
  fs4.writeFileSync(absoluteFilepath, page);
  return page;
}

// src/commands/browser/saveRecordingScreen.ts
import fs5 from "node:fs";
async function saveRecordingScreen(filepath) {
  if (typeof filepath !== "string") {
    throw new Error("saveRecordingScreen expects a filepath");
  }
  const absoluteFilepath = getAbsoluteFilepath(filepath);
  await assertDirectoryExists(absoluteFilepath);
  const videoBuffer = await this.stopRecordingScreen();
  const video = Buffer.from(videoBuffer, "base64");
  fs5.writeFileSync(absoluteFilepath, video);
  return video;
}

// src/commands/browser/saveScreenshot.ts
import fs6 from "node:fs";
import { getBrowserObject as getBrowserObject6 } from "@wdio/utils";
async function saveScreenshot(filepath) {
  if (typeof filepath !== "string" || !filepath.endsWith(".png")) {
    throw new Error('saveScreenshot expects a filepath of type string and ".png" file ending');
  }
  const absoluteFilepath = getAbsoluteFilepath(filepath);
  await assertDirectoryExists(absoluteFilepath);
  let screenBuffer;
  if (this.isBidi) {
    const browser = getBrowserObject6(this);
    const contextManager2 = getContextManager(browser);
    const context = await contextManager2.getCurrentContext();
    const { data } = await this.browsingContextCaptureScreenshot({ context });
    screenBuffer = data;
  } else {
    screenBuffer = await this.takeScreenshot();
  }
  const screenshot = Buffer.from(screenBuffer, "base64");
  fs6.writeFileSync(absoluteFilepath, screenshot);
  return screenshot;
}

// src/commands/browser/scroll.ts
import logger10 from "@wdio/logger";
var log10 = logger10("webdriverio");
function scroll(x = 0, y = 0) {
  if (!x && !y) {
    return log10.warn('"scroll" command was called with no parameters, skipping execution');
  }
  if (this.isMobile) {
    return this.execute((x2, y2) => window.scrollBy(x2, y2), x, y);
  }
  return this.action("wheel").scroll({
    deltaX: x,
    deltaY: y,
    duration: 0
  }).perform();
}

// src/commands/browser/setCookies.ts
async function setCookies(cookieObjs) {
  const cookieObjsList = !Array.isArray(cookieObjs) ? [cookieObjs] : cookieObjs;
  if (cookieObjsList.some((obj) => typeof obj !== "object")) {
    throw new Error("Invalid input (see https://webdriver.io/docs/api/browser/setCookies for documentation)");
  }
  for (const cookieObj of cookieObjsList) {
    await this.addCookie(cookieObj);
  }
  return;
}

// src/commands/browser/setTimeout.ts
async function setTimeout2(timeouts) {
  if (typeof timeouts !== "object") {
    throw new Error('Parameter for "setTimeout" command needs to be an object');
  }
  const timeoutValues = Object.values(timeouts);
  if (timeoutValues.length && timeoutValues.every((timeout) => typeof timeout !== "number" || timeout < 0 || timeout > Number.MAX_SAFE_INTEGER)) {
    throw new Error("Specified timeout values are not valid integer (see https://webdriver.io/docs/api/browser/setTimeout for documentation).");
  }
  const implicit = timeouts.implicit;
  const pageLoad = timeouts["page load"] || timeouts.pageLoad;
  const script = timeouts.script;
  const setTimeouts = this.setTimeouts.bind(this);
  return setTimeouts(implicit, pageLoad, script);
}

// src/commands/browser/setViewport.ts
import { getBrowserObject as getBrowserObject7 } from "@wdio/utils";
var minWindowSize = 0;
var maxWindowSize = Number.MAX_SAFE_INTEGER;
async function setViewport(options) {
  if (typeof options.width !== "number" || typeof options.height !== "number") {
    throw new Error("setViewport expects width and height of type number");
  }
  if (options.width < minWindowSize || options.width > maxWindowSize || options.height < minWindowSize || options.height > maxWindowSize) {
    throw new Error("setViewport expects width and height to be a number in the 0 to 2^31 \u2212 1 range");
  }
  if (options.devicePixelRatio && (typeof options.devicePixelRatio !== "number" || options.devicePixelRatio < 0)) {
    throw new Error("setViewport expects devicePixelRatio to be a number in the 0 to 2^31 \u2212 1 range");
  }
  const browser = getBrowserObject7(this);
  const contextManager2 = getContextManager(browser);
  const context = await contextManager2.getCurrentContext();
  await browser.browsingContextSetViewport({
    context,
    devicePixelRatio: options.devicePixelRatio || 1,
    viewport: {
      width: options.width,
      height: options.height
    }
  });
}

// src/commands/browser/setWindowSize.ts
import { getBrowserObject as getBrowserObject8 } from "@wdio/utils";
var minWindowSize2 = 0;
var maxWindowSize2 = Number.MAX_SAFE_INTEGER;
async function setWindowSize(width, height) {
  if (typeof width !== "number" || typeof height !== "number") {
    throw new Error("setWindowSize expects width and height of type number");
  }
  if (width < minWindowSize2 || width > maxWindowSize2 || height < minWindowSize2 || height > maxWindowSize2) {
    throw new Error("setWindowSize expects width and height to be a number in the 0 to 2^31 \u2212 1 range");
  }
  const browser = getBrowserObject8(this);
  await browser.setWindowRect(null, null, width, height);
}

// src/commands/browser/switchWindow.ts
async function switchWindow(matcher) {
  if (typeof matcher !== "string" && !(matcher instanceof RegExp)) {
    throw new Error('Unsupported parameter for switchWindow, required is "string" or an RegExp');
  }
  const tabs = await this.getWindowHandles();
  const matchesTarget = (target) => {
    if (typeof matcher === "string") {
      return target.includes(matcher);
    }
    return !!target.match(matcher);
  };
  for (const tab of tabs) {
    await this.switchToWindow(tab);
    const url6 = await this.getUrl();
    if (matchesTarget(url6)) {
      return tab;
    }
    const title = await this.getTitle();
    if (matchesTarget(title)) {
      return tab;
    }
    const windowName = await this.execute(
      /* istanbul ignore next */
      () => window.name
    );
    if (windowName && matchesTarget(windowName)) {
      return tab;
    }
  }
  throw new Error(`No window found with title, url or name matching "${matcher}"`);
}

// src/commands/browser/throttle.ts
import logger11 from "@wdio/logger";
import { getBrowserObject as getBrowserObject9 } from "@wdio/utils";
var log11 = logger11("webdriverio:throttle");
async function throttle(params) {
  log11.warn('Command "throttle" is deprecated and will be removed with the next major version release! Use `throttleNetwork` instead.');
  const browser = getBrowserObject9(this);
  await browser.throttleNetwork(params);
}

// src/commands/browser/throttleCPU.ts
async function throttleCPU(factor) {
  if (typeof factor !== "number") {
    throw new Error('Invalid factor for "throttleCPU". Expected it to be a number (int)');
  }
  const failedConnectionMessage = "No Puppeteer connection could be established which is required to use this command";
  await this.getPuppeteer();
  if (!this.puppeteer) {
    throw new Error(failedConnectionMessage);
  }
  const pages = await this.puppeteer.pages();
  if (!pages.length) {
    throw new Error(failedConnectionMessage);
  }
  const client = await pages[0].target().createCDPSession();
  await client.send("Emulation.setCPUThrottlingRate", { rate: factor });
}

// src/commands/browser/throttleNetwork.ts
import { getBrowserObject as getBrowserObject10 } from "@wdio/utils";
var NETWORK_PRESETS = {
  "offline": {
    offline: true,
    downloadThroughput: 0,
    uploadThroughput: 0,
    latency: 1
  },
  "GPRS": {
    offline: false,
    downloadThroughput: 50 * 1024 / 8,
    uploadThroughput: 20 * 1024 / 8,
    latency: 500
  },
  "Regular2G": {
    offline: false,
    downloadThroughput: 250 * 1024 / 8,
    uploadThroughput: 50 * 1024 / 8,
    latency: 300
  },
  "Good2G": {
    offline: false,
    downloadThroughput: 450 * 1024 / 8,
    uploadThroughput: 150 * 1024 / 8,
    latency: 150
  },
  "Regular3G": {
    offline: false,
    downloadThroughput: 750 * 1024 / 8,
    uploadThroughput: 250 * 1024 / 8,
    latency: 100
  },
  "Good3G": {
    offline: false,
    downloadThroughput: 1.5 * 1024 * 1024 / 8,
    uploadThroughput: 750 * 1024 / 8,
    latency: 40
  },
  "Regular4G": {
    offline: false,
    downloadThroughput: 4 * 1024 * 1024 / 8,
    uploadThroughput: 3 * 1024 * 1024 / 8,
    latency: 20
  },
  "DSL": {
    offline: false,
    downloadThroughput: 2 * 1024 * 1024 / 8,
    uploadThroughput: 1 * 1024 * 1024 / 8,
    latency: 5
  },
  "WiFi": {
    offline: false,
    downloadThroughput: 30 * 1024 * 1024 / 8,
    uploadThroughput: 15 * 1024 * 1024 / 8,
    latency: 2
  },
  "online": {
    offline: false,
    latency: 0,
    downloadThroughput: -1,
    uploadThroughput: -1
  }
};
var NETWORK_PRESET_TYPES = Object.keys(NETWORK_PRESETS);
async function throttleNetwork(params) {
  if (
    /**
     * check string parameter
     */
    (typeof params !== "string" || !NETWORK_PRESET_TYPES.includes(params)) && /**
     * check object parameter
     */
    typeof params !== "object"
  ) {
    throw new Error(`Invalid parameter for "throttleNetwork". Expected it to be typeof object or one of the following values: ${NETWORK_PRESET_TYPES.join(", ")} but found "${params}"`);
  }
  if (this.isSauce) {
    const browser = getBrowserObject10(this);
    await browser.sauceThrottleNetwork(params);
    return null;
  }
  const failedConnectionMessage = "No Puppeteer connection could be established which is required to use this command";
  await this.getPuppeteer();
  if (!this.puppeteer) {
    throw new Error(failedConnectionMessage);
  }
  const pages = await this.puppeteer.pages();
  if (!pages.length) {
    throw new Error(failedConnectionMessage);
  }
  const client = await pages[0].target().createCDPSession();
  await client.send(
    "Network.emulateNetworkConditions",
    typeof params === "string" ? NETWORK_PRESETS[params] : params
  );
  return null;
}

// src/commands/constant.ts
var TOUCH_ACTIONS = ["press", "longPress", "tap", "moveTo", "wait", "release"];
var POS_ACTIONS = TOUCH_ACTIONS.slice(0, 4);
var ACCEPTED_OPTIONS = ["x", "y", "element"];
var formatArgs = function(scope, actions2) {
  return actions2.map((action2) => {
    if (Array.isArray(action2)) {
      return formatArgs(scope, action2);
    }
    if (typeof action2 === "string") {
      action2 = { action: action2 };
    }
    const formattedAction = {
      action: action2.action,
      options: {}
    };
    const actionElement = action2.element && typeof action2.element.elementId === "string" ? action2.element.elementId : scope.elementId;
    if (POS_ACTIONS.includes(action2.action) && formattedAction.options && actionElement) {
      formattedAction.options.element = actionElement;
    }
    if (formattedAction.options && typeof action2.x === "number" && isFinite(action2.x)) {
      formattedAction.options.x = action2.x;
    }
    if (formattedAction.options && typeof action2.y === "number" && isFinite(action2.y)) {
      formattedAction.options.y = action2.y;
    }
    if (formattedAction.options && action2.ms) {
      formattedAction.options.ms = action2.ms;
    }
    if (formattedAction.options && Object.keys(formattedAction.options).length === 0) {
      delete formattedAction.options;
    }
    return formattedAction;
  });
};
var validateParameters = (params) => {
  const options = Object.keys(params.options || {});
  if (params.action === "release" && options.length !== 0) {
    throw new Error(
      `action "release" doesn't accept any options ("${options.join('", "')}" found)`
    );
  }
  if (params.action === "wait" && (options.includes("x") || options.includes("y"))) {
    throw new Error(`action "wait" doesn't accept x or y options`);
  }
  if (POS_ACTIONS.includes(params.action)) {
    for (const option in params.options) {
      if (!ACCEPTED_OPTIONS.includes(option)) {
        throw new Error(`action "${params.action}" doesn't accept "${option}" as option`);
      }
    }
    if (options.length === 0) {
      throw new Error(
        `Touch actions like "${params.action}" need at least some kind of position information like "element", "x" or "y" options, you've none given.`
      );
    }
  }
};
var touchAction = function(actions2) {
  if (!this.multiTouchPerform || !this.touchPerform) {
    throw new Error("touchAction can be used with Appium only.");
  }
  if (!Array.isArray(actions2)) {
    actions2 = [actions2];
  }
  const formattedAction = formatArgs(this, actions2);
  const protocolCommand = Array.isArray(actions2[0]) ? this.multiTouchPerform.bind(this) : this.touchPerform.bind(this);
  formattedAction.forEach((params) => validateParameters(params));
  return protocolCommand(formattedAction);
};

// src/commands/browser/touchAction.ts
function touchAction2(actions2) {
  return touchAction.call(this, actions2);
}

// src/commands/browser/uploadFile.ts
import fs7 from "node:fs";
import path2 from "node:path";
import archiver from "archiver";
async function uploadFile(localPath) {
  if (typeof localPath !== "string") {
    throw new Error("number or type of arguments don't agree with uploadFile command");
  }
  if (typeof this.file !== "function") {
    throw new Error(`The uploadFile command is not available in ${this.capabilities.browserName}`);
  }
  const zipData = [];
  const source = fs7.createReadStream(localPath);
  return new Promise((resolve5, reject) => {
    archiver("zip").on("error", (err) => reject(err)).on("data", (data) => zipData.push(data)).on("end", () => this.file(Buffer.concat(zipData).toString("base64")).then((localPath2) => resolve5(localPath2), reject)).append(source, { name: path2.basename(localPath) }).finalize();
  });
}

// src/networkManager.ts
var networkManager = /* @__PURE__ */ new Map();
function getNetworkManager(browser) {
  const existingNetworkManager = networkManager.get(browser);
  if (existingNetworkManager) {
    return existingNetworkManager;
  }
  const newContext = new NetworkManager(browser);
  networkManager.set(browser, newContext);
  return newContext;
}
var NetworkManager = class {
  #browser;
  #initialize;
  #requests = /* @__PURE__ */ new Map();
  constructor(browser) {
    this.#browser = browser;
    if (!browser.isBidi || process.env.VITEST_WORKER_ID || browser.options?.automationProtocol !== "webdriver") {
      this.#initialize = Promise.resolve(true);
      return;
    }
    this.#initialize = this.#browser.sessionSubscribe({
      events: [
        "browsingContext.navigationStarted",
        "network.responseCompleted",
        "network.beforeRequestSent",
        "network.fetchError"
      ]
    }).then(() => true, () => false);
    this.#browser.on("browsingContext.navigationStarted", this.#navigationStarted.bind(this));
    this.#browser.on("network.responseCompleted", this.#responseCompleted.bind(this));
    this.#browser.on("network.beforeRequestSent", this.#beforeRequestSent.bind(this));
    this.#browser.on("network.fetchError", this.#fetchError.bind(this));
  }
  async initialize() {
    return this.#initialize;
  }
  #beforeRequestSent(log19) {
    if (log19.navigation) {
      return;
    }
    const request = log19.context ? this.#requests.get(log19.context) : void 0;
    if (!request) {
      return;
    }
    const { request: id, headers, cookies, url: url6 } = log19.request;
    request.children?.push({
      id,
      url: url6,
      headers: headerListToObject(headers),
      cookies: cookies.map((cookie) => ({
        name: cookie.name,
        value: cookie.value.type === "string" ? cookie.value.value : atob(cookie.value.value),
        domain: cookie.domain,
        path: cookie.path,
        size: cookie.size,
        httpOnly: cookie.httpOnly,
        secure: cookie.secure,
        sameSite: cookie.sameSite,
        expiry: cookie.expiry
      })),
      timestamp: log19.timestamp
    });
  }
  #navigationStarted(log19) {
    if (
      /**
       * we need a navigation id to identify the request
       */
      !log19.navigation || /**
       * ignore urls that do not start with http
       */
      !log19.url.startsWith("http")
    ) {
      if (log19.navigation === null && log19.url === "") {
        return this.#requests.set(log19.context, {
          url: "",
          headers: {},
          timestamp: log19.timestamp,
          redirectChain: [],
          children: []
        });
      }
      return;
    }
    this.#requests.set(log19.context, {
      url: log19.url,
      headers: {},
      timestamp: log19.timestamp,
      navigation: log19.navigation,
      redirectChain: [],
      children: []
    });
  }
  #fetchError(log19) {
    const response = log19.context ? this.#requests.get(log19.context) : void 0;
    if (!response) {
      return;
    }
    const request = response.children?.find((child) => child.id === log19.request.request);
    if (!request) {
      return;
    }
    request.error = log19.errorText;
  }
  #responseCompleted(log19) {
    const response = log19.context ? this.#requests.get(log19.context) : void 0;
    if (!response) {
      return;
    }
    if (!response.navigation && response.url === "") {
      response.url = log19.request.url;
      response.navigation = log19.navigation;
    }
    if (log19.navigation === response.navigation) {
      if (response.url !== log19.response.url) {
        response.redirectChain?.push(response.url);
      }
      response.url = log19.response.url;
      const { headers: requestHeaders } = log19.request;
      const { fromCache, headers: responseHeaders, mimeType, status } = log19.response;
      response.headers = headerListToObject(requestHeaders), response.response = {
        fromCache,
        headers: headerListToObject(responseHeaders),
        mimeType,
        status
      };
      return;
    }
    const request = response.children?.find((child) => child.id === log19.request.request);
    if (!request) {
      return;
    }
    request.response = {
      fromCache: log19.response.fromCache,
      headers: headerListToObject(log19.response.headers),
      mimeType: log19.response.mimeType,
      status: log19.response.status
    };
    response.children?.push(request);
  }
  getRequestResponseData(context) {
    return this.#requests.get(context);
  }
  /**
   * Returns the number of requests that are currently pending.
   * @param context browsing context id
   * @returns the number of requests that are currently pending
   */
  getPendingRequests(context) {
    const request = this.#requests.get(context);
    if (!request) {
      throw new Error(`Couldn't find request for context ${context}`);
    }
    const subRequests = request.children || [];
    return subRequests.filter((child) => (
      /**
       * either the request has no response yet
       */
      !child.response && /**
       * and there was no request error
       */
      !child.error
    ));
  }
};
function headerListToObject(headers) {
  return headers.reduce((acc, { name, value }) => {
    acc[name] = value.value;
    return acc;
  }, {});
}

// src/commands/browser/url.ts
var DEFAULT_NETWORK_IDLE_TIMEOUT = 5e3;
var DEFAULT_WAIT_STATE = "complete";
async function url3(path4, options = {}) {
  if (typeof path4 !== "string") {
    throw new Error('Parameter for "url" command needs to be type of string');
  }
  if (typeof this.options.baseUrl === "string" && this.options.baseUrl) {
    path4 = new URL(path4, this.options.baseUrl).href;
  }
  if (this.isBidi) {
    let resetPreloadScript;
    const contextManager2 = getContextManager(this);
    const context = await contextManager2.getCurrentContext();
    if (options.onBeforeLoad) {
      if (typeof options.onBeforeLoad !== "function") {
        throw new Error(`Option "onBeforeLoad" must be a function, but received: ${typeof options.onBeforeLoad}`);
      }
      resetPreloadScript = await this.addInitScript(options.onBeforeLoad);
    }
    if (options.auth) {
      options.headers = {
        ...options.headers || {},
        Authorization: `Basic ${btoa(`${options.auth.user}:${options.auth.pass}`)}`
      };
    }
    let mock2;
    if (options.headers) {
      mock2 = await this.mock(path4);
      mock2.requestOnce({ headers: options.headers });
    }
    const wait = options.wait === "networkIdle" ? "complete" : options.wait || DEFAULT_WAIT_STATE;
    await this.browsingContextNavigate({
      context,
      url: path4,
      wait
    });
    const network = networkManager.get(this);
    const request = network?.getRequestResponseData(context);
    if (mock2) {
      await mock2.restore();
    }
    if (network && options.wait === "networkIdle") {
      const timeout = options.timeout || DEFAULT_NETWORK_IDLE_TIMEOUT;
      await this.waitUntil(async () => {
        return network.getPendingRequests(context).length === 0;
      }, {
        timeout,
        timeoutMsg: `Navigation to '${path4}' timed out after ${timeout}ms with ${network.getPendingRequests(context).length} (${network.getPendingRequests(context).map((r) => r.url).join(", ")}) pending requests`
      });
    }
    if (resetPreloadScript) {
      await resetPreloadScript.remove();
    }
    return request;
  }
  if (Object.keys(options).length > 0) {
    throw new Error("Setting url options is only supported when automating browser using WebDriver Bidi protocol");
  }
  await this.navigateTo(validateUrl(path4));
}

// src/commands/browser/waitUntil.ts
function waitUntil(condition, {
  timeout = this.options.waitforTimeout,
  interval = this.options.waitforInterval,
  timeoutMsg
} = {}) {
  if (typeof condition !== "function") {
    throw new Error("Condition is not a function");
  }
  if (typeof timeout !== "number") {
    timeout = this.options.waitforTimeout;
  }
  if (typeof interval !== "number") {
    interval = this.options.waitforInterval;
  }
  const fn = condition.bind(this);
  const timer = new Timer_default(interval, timeout, fn, true);
  return timer.catch((e) => {
    if (e.message === "timeout") {
      if (typeof timeoutMsg === "string") {
        throw new Error(timeoutMsg);
      }
      throw new Error(`waitUntil condition timed out after ${timeout}ms`);
    }
    throw new Error(`waitUntil condition failed with the following reason: ${e && e.message || e}`);
  });
}

// src/commands/element.ts
var element_exports = {};
__export(element_exports, {
  $: () => $2,
  $$: () => $$2,
  addValue: () => addValue,
  clearValue: () => clearValue,
  click: () => click,
  custom$: () => custom$2,
  custom$$: () => custom$$2,
  doubleClick: () => doubleClick,
  dragAndDrop: () => dragAndDrop,
  execute: () => execute2,
  executeAsync: () => executeAsync2,
  getAttribute: () => getAttribute,
  getCSSProperty: () => getCSSProperty,
  getComputedLabel: () => getComputedLabel,
  getComputedRole: () => getComputedRole,
  getElement: () => getElement2,
  getHTML: () => getHTML,
  getLocation: () => getLocation,
  getProperty: () => getProperty,
  getSize: () => getSize,
  getTagName: () => getTagName,
  getText: () => getText,
  getValue: () => getValue,
  isClickable: () => isClickable,
  isDisplayed: () => isDisplayed,
  isEnabled: () => isEnabled,
  isEqual: () => isEqual,
  isExisting: () => isExisting,
  isFocused: () => isFocused,
  isSelected: () => isSelected,
  isStable: () => isStable,
  moveTo: () => moveTo,
  nextElement: () => nextElement,
  parentElement: () => parentElement,
  previousElement: () => previousElement,
  react$: () => react$2,
  react$$: () => react$$2,
  saveScreenshot: () => saveScreenshot2,
  scrollIntoView: () => scrollIntoView,
  selectByAttribute: () => selectByAttribute,
  selectByIndex: () => selectByIndex,
  selectByVisibleText: () => selectByVisibleText,
  setValue: () => setValue,
  shadow$: () => shadow$,
  shadow$$: () => shadow$$,
  touchAction: () => touchAction3,
  waitForClickable: () => waitForClickable,
  waitForDisplayed: () => waitForDisplayed,
  waitForEnabled: () => waitForEnabled,
  waitForExist: () => waitForExist,
  waitForStable: () => waitForStable,
  waitUntil: () => waitUntil2
});

// src/commands/element/$$.ts
var $$2 = $$;

// src/commands/element/$.ts
var $2 = $;

// src/commands/element/addValue.ts
var VALID_TYPES = ["string", "number"];
function addValue(value) {
  if (!VALID_TYPES.includes(typeof value)) {
    throw new Error(
      'The setValue/addValue command only take string or number values. If you like to use special characters, use the "keys" command.'
    );
  }
  return this.elementSendKeys(this.elementId, value.toString());
}

// src/commands/element/clearValue.ts
function clearValue() {
  return this.elementClear(this.elementId);
}

// src/commands/element/click.ts
import logger12 from "@wdio/logger";
import { getBrowserObject as getBrowserObject11 } from "@wdio/utils";
var log12 = logger12("webdriver");
function click(options) {
  if (typeof options !== "undefined") {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new TypeError("Options must be an object");
    }
    return actionClick(this, options);
  }
  return elementClick(this);
}
async function workaround(element) {
  await element.scrollIntoView({ block: "center", inline: "center" });
}
async function elementClick(element) {
  try {
    return await element.elementClick(element.elementId);
  } catch (error) {
    let err = error;
    if (typeof error === "string") {
      err = new Error(error);
    }
    if (!err.message.includes("element click intercepted")) {
      throw err;
    }
    await workaround(element);
    return element.elementClick(element.elementId);
  }
}
async function actionClick(element, options) {
  const defaultOptions = {
    button: 0,
    x: 0,
    y: 0,
    skipRelease: false
  };
  const { button, x, y, skipRelease } = { ...defaultOptions, ...options };
  if (typeof x !== "number" || typeof y !== "number" || !Number.isInteger(x) || !Number.isInteger(y)) {
    throw new TypeError("Coordinates must be integers");
  }
  if (!buttonValue.includes(button)) {
    throw new Error("Button type not supported.");
  }
  const browser = getBrowserObject11(element);
  if (x || y) {
    const { width, height } = await browser.getElementRect(element.elementId);
    if (x && x < -Math.floor(width / 2) || x && x > Math.floor(width / 2)) {
      log12.warn("x would cause a out of bounds error as it goes outside of element");
    }
    if (y && y < -Math.floor(height / 2) || y && y > Math.floor(height / 2)) {
      log12.warn("y would cause a out of bounds error as it goes outside of element");
    }
  }
  const clickNested = async () => {
    await browser.action("pointer", {
      parameters: { pointerType: "mouse" }
    }).move({ origin: element, x, y }).down({ button }).up({ button }).perform(skipRelease);
  };
  try {
    return await clickNested();
  } catch {
    await workaround(element);
    return clickNested();
  }
}

// src/commands/element/custom$$.ts
import { ELEMENT_KEY as ELEMENT_KEY8 } from "webdriver";
import { getBrowserObject as getBrowserObject12 } from "@wdio/utils";
async function custom$$2(strategyName, ...strategyArguments) {
  const browserObject = getBrowserObject12(this);
  const strategy = browserObject.strategies.get(strategyName);
  if (!strategy) {
    throw Error("No strategy found for " + strategyName);
  }
  if (!this.elementId) {
    throw Error(`Can't call custom$ on element with selector "${this.selector}" because element wasn't found`);
  }
  const strategyRef = { strategy, strategyName, strategyArguments: [...strategyArguments, this] };
  let res = await browserObject.execute(strategy, ...strategyArguments, this);
  if (!Array.isArray(res)) {
    res = [res];
  }
  res = res.filter((el) => !!el && typeof el[ELEMENT_KEY8] === "string");
  const elements = res.length ? await getElements.call(this, strategyRef, res) : [];
  return enhanceElementsArray(elements, this, strategyName, "custom$$", strategyArguments);
}

// src/commands/element/custom$.ts
import { ELEMENT_KEY as ELEMENT_KEY9 } from "webdriver";
import { getBrowserObject as getBrowserObject13 } from "@wdio/utils";
async function custom$2(strategyName, ...strategyArguments) {
  const browserObject = getBrowserObject13(this);
  const strategy = browserObject.strategies.get(strategyName);
  if (!strategy) {
    throw Error("No strategy found for " + strategyName);
  }
  if (!this.elementId) {
    throw Error(`Can't call custom$ on element with selector "${this.selector}" because element wasn't found`);
  }
  const strategyRef = { strategy, strategyName, strategyArguments: [...strategyArguments, this] };
  let res = await browserObject.execute(strategy, ...strategyArguments, this);
  if (Array.isArray(res)) {
    res = res[0];
  }
  if (res && typeof res[ELEMENT_KEY9] === "string") {
    return await getElement.call(this, strategyRef, res);
  }
  return await getElement.call(this, strategyRef, new Error("no such element"));
}

// src/commands/element/doubleClick.ts
import { getBrowserObject as getBrowserObject14 } from "@wdio/utils";
async function doubleClick() {
  const browser = getBrowserObject14(this);
  return browser.action("pointer", { parameters: { pointerType: "mouse" } }).move({ origin: this }).down().up().pause(10).down().up().perform();
}

// src/commands/element/dragAndDrop.ts
import { ELEMENT_KEY as ELEMENT_KEY10 } from "webdriver";
import { getBrowserObject as getBrowserObject15 } from "@wdio/utils";
var ACTION_BUTTON = 0;
async function dragAndDrop(target, { duration = 10 } = {}) {
  const moveToCoordinates = target;
  const moveToElement = target;
  if (
    /**
     * no target was specified
     */
    !target || /**
     * target is not from type element
     */
    target.constructor.name !== "Element" && /**
     * and is also not an object with x and y number parameters
     */
    (typeof moveToCoordinates.x !== "number" || typeof moveToCoordinates.y !== "number")
  ) {
    throw new Error('command dragAndDrop requires an WebdriverIO Element or and object with "x" and "y" variables as first parameter');
  }
  const isMovingToElement = target.constructor.name === "Element";
  const sourceRef = { [ELEMENT_KEY10]: this[ELEMENT_KEY10] };
  const targetRef = { [ELEMENT_KEY10]: moveToElement[ELEMENT_KEY10] };
  const origin = sourceRef;
  const targetOrigin = isMovingToElement ? targetRef : "pointer";
  const targetX = isMovingToElement ? 0 : moveToCoordinates.x;
  const targetY = isMovingToElement ? 0 : moveToCoordinates.y;
  const browser = getBrowserObject15(this);
  return browser.action("pointer").move({ duration: 0, origin, x: 0, y: 0 }).down({ button: ACTION_BUTTON }).pause(10).move({ duration, origin: targetOrigin, x: targetX, y: targetY }).up({ button: ACTION_BUTTON }).perform();
}

// src/commands/element/execute.ts
import { getBrowserObject as getBrowserObject16 } from "@wdio/utils";
async function execute2(script, ...args) {
  if (typeof script !== "string" && typeof script !== "function") {
    throw new Error("number or type of arguments don't agree with execute protocol command");
  }
  if (this.isBidi) {
    const browser = getBrowserObject16(this);
    const contextManager2 = getContextManager(browser);
    const context = await contextManager2.getCurrentContext();
    const result = await browser.scriptCallFunction({
      functionDeclaration: script.toString(),
      awaitPromise: false,
      arguments: [this, ...args].map((arg) => LocalValue.getArgument(arg)),
      target: {
        context
      }
    });
    return parseScriptResult(result);
  }
  if (typeof script === "function") {
    script = `return (${script}).apply(null, arguments)`;
  }
  return this.executeScript(script, verifyArgsAndStripIfElement([this, ...args]));
}

// src/commands/element/executeAsync.ts
import { getBrowserObject as getBrowserObject17 } from "@wdio/utils";
async function executeAsync2(script, ...args) {
  if (typeof script !== "string" && typeof script !== "function") {
    throw new Error("number or type of arguments don't agree with execute protocol command");
  }
  if (this.isBidi) {
    const browser = getBrowserObject17(this);
    const contextManager2 = getContextManager(browser);
    const context = await contextManager2.getCurrentContext();
    const functionDeclaration = `function (...args) {
            return new Promise(async (resolve, reject) => {
                try {
                    await ${script.toString()}.call(this, ...args, resolve)
                } catch (err) {
                    return reject(err)
                }
            })
        }`;
    const result = await browser.scriptCallFunction({
      functionDeclaration,
      awaitPromise: true,
      arguments: [this, ...args].map((arg) => LocalValue.getArgument(arg)),
      target: {
        context
      }
    });
    return parseScriptResult(result);
  }
  if (typeof script === "function") {
    script = `return (${script}).apply(null, arguments)`;
  }
  return this.executeAsyncScript(script, verifyArgsAndStripIfElement([this, ...args]));
}

// src/commands/element/getAttribute.ts
function getAttribute(attributeName) {
  return this.getElementAttribute(this.elementId, attributeName);
}

// src/commands/element/getCSSProperty.ts
import cssShorthandProps from "css-shorthand-properties";
import { getBrowserObject as getBrowserObject18 } from "@wdio/utils";
async function getCSSProperty(cssProperty, pseudoElement) {
  const getCSSProperty2 = cssShorthandProps.isShorthand(cssProperty) ? getShorthandPropertyCSSValue : getPropertyCSSValue;
  const cssValue2 = await getCSSProperty2.call(
    this,
    {
      cssProperty,
      pseudoElement
    }
  );
  return parseCSS(cssValue2, cssProperty);
}
async function getShorthandPropertyCSSValue(options) {
  const { pseudoElement, cssProperty } = options;
  const properties = getShorthandProperties(cssProperty);
  if (pseudoElement) {
    const cssValues2 = await Promise.all(
      properties.map((prop) => getPseudoElementCSSValue(
        this,
        {
          pseudoElement,
          cssProperty: prop
        }
      ))
    );
    return mergeEqualSymmetricalValue(cssValues2);
  }
  const cssValues = await Promise.all(
    properties.map((prop) => this.getElementCSSValue(this.elementId, prop))
  );
  return mergeEqualSymmetricalValue(cssValues);
}
async function getPropertyCSSValue(options) {
  const { pseudoElement, cssProperty } = options;
  if (pseudoElement) {
    return await getPseudoElementCSSValue(
      this,
      {
        pseudoElement,
        cssProperty
      }
    );
  }
  return await this.getElementCSSValue(this.elementId, cssProperty);
}
function getShorthandProperties(cssProperty) {
  return cssShorthandProps.expand(cssProperty);
}
function mergeEqualSymmetricalValue(cssValues) {
  let newCssValues = [...cssValues];
  while (newCssValues.length % 2 === 0) {
    const mergedValues = [
      newCssValues.slice(0, newCssValues.length / 2).join(" "),
      newCssValues.slice(newCssValues.length / 2).join(" ")
    ];
    const hasEqualProperties = mergedValues.every((v) => v === mergedValues[0]);
    if (!hasEqualProperties) {
      break;
    }
    newCssValues = newCssValues.slice(0, newCssValues.length / 2);
  }
  return newCssValues.join(" ");
}
async function getPseudoElementCSSValue(elem, options) {
  const browser = getBrowserObject18(elem);
  const { cssProperty, pseudoElement } = options;
  const cssValue2 = await browser.execute(
    (elem2, pseudoElement2, cssProperty2) => window.getComputedStyle(elem2, pseudoElement2)[cssProperty2],
    elem,
    pseudoElement,
    cssProperty
  );
  return cssValue2;
}

// src/commands/element/getComputedRole.ts
function getComputedRole() {
  return this.getElementComputedRole(this.elementId);
}

// src/commands/element/getComputedLabel.ts
function getComputedLabel() {
  return this.getElementComputedLabel(this.elementId);
}

// src/commands/element/getElement.ts
async function getElement2() {
  return this;
}

// src/commands/element/getHTML.ts
import { ELEMENT_KEY as ELEMENT_KEY11 } from "webdriver";
import { prettify as prettifyFn } from "htmlfy";
import { getBrowserObject as getBrowserObject19 } from "@wdio/utils";

// src/shadowRoot.ts
import logger13 from "@wdio/logger";
import customElementWrapper from "./scripts/customElement.js";
var shadowRootManager = /* @__PURE__ */ new Map();
var log13 = logger13("webdriverio:ShadowRootManager");
function getShadowRootManager(browser) {
  const existingShadowRootManager = shadowRootManager.get(browser);
  if (existingShadowRootManager) {
    return existingShadowRootManager;
  }
  const newContext = new ShadowRootManager(browser);
  shadowRootManager.set(browser, newContext);
  return newContext;
}
var ShadowRootManager = class {
  #browser;
  #initialize;
  #shadowRoots = /* @__PURE__ */ new Map();
  #frameDepth = 0;
  constructor(browser) {
    this.#browser = browser;
    if (!browser.isBidi || process.env.VITEST_WORKER_ID || browser.options?.automationProtocol !== "webdriver") {
      this.#initialize = Promise.resolve(true);
      return;
    }
    this.#initialize = this.#browser.sessionSubscribe({
      events: ["log.entryAdded"]
    }).then(() => true, () => false);
    this.#browser.on("log.entryAdded", this.handleLogEntry.bind(this));
    this.#browser.on("result", this.#commandResultHandler.bind(this));
    browser.scriptAddPreloadScript({
      functionDeclaration: customElementWrapper.toString()
    });
  }
  async initialize() {
    return this.#initialize;
  }
  /**
   * keep track of frame depth
   */
  #commandResultHandler(result) {
    if (result.command === "switchToFrame" && !result.result.error) {
      this.#frameDepth++;
    }
    if (result.command === "switchToParentFrame" && !result.result.error) {
      this.#frameDepth = Math.max(0, this.#frameDepth - 1);
    }
  }
  /**
   * check if we are within a frame
   * @returns {boolean} true if we are within a frame
   */
  isWithinFrame() {
    return this.#frameDepth > 0;
  }
  /**
   * capture shadow root elements propagated through console.debug
   */
  handleLogEntry(logEntry) {
    const args = "args" in logEntry && logEntry.level === "debug" ? logEntry.args : void 0;
    if (!args || args[0].type !== "string" || args[0].value !== "[WDIO]" || args[1].type !== "string") {
      return;
    }
    if (!logEntry.source.context) {
      return;
    }
    const eventType = args[1].value;
    if (eventType === "newShadowRoot" && args[2].type === "node" && args[3].type === "node") {
      const [
        /* [WDIO] */
        ,
        /* newShadowRoot */
        ,
        shadowElem,
        rootElem,
        isDocument
      ] = args;
      if (!this.#shadowRoots.has(logEntry.source.context)) {
        if (!rootElem.sharedId) {
          throw new Error(`Expected "sharedId" parameter from object ${rootElem}`);
        }
        this.#shadowRoots.set(logEntry.source.context, new ShadowRootTree(rootElem.sharedId));
      } else if (isDocument.type === "boolean" && isDocument.value) {
        if (!rootElem.sharedId) {
          throw new Error(`Expected "sharedId" parameter from object ${rootElem}`);
        }
        const tree2 = this.#shadowRoots.get(logEntry.source.context);
        if (tree2?.element !== rootElem.sharedId) {
          this.#shadowRoots.set(logEntry.source.context, new ShadowRootTree(rootElem.sharedId));
        }
      }
      const tree = this.#shadowRoots.get(logEntry.source.context);
      if (!tree) {
        throw new Error(`Couldn't find tree for context id ${logEntry.source.context}`);
      }
      if (
        // we expect an element id
        !shadowElem.sharedId || // we expect the element to have a shadow root
        !shadowElem.value?.shadowRoot?.sharedId || // we expect the shadow root to have a proper type
        shadowElem.value.shadowRoot.value?.nodeType !== 11
      ) {
        return log13.warn(`Expected element with shadow root but found <${shadowElem.value?.localName} />`);
      }
      log13.info(`Registered new shadow root for element <${shadowElem.value.localName} /> with id ${shadowElem.value.shadowRoot.sharedId}`);
      const newTree = new ShadowRootTree(
        shadowElem.sharedId,
        shadowElem.value.shadowRoot.sharedId,
        shadowElem.value.shadowRoot.value.mode
      );
      rootElem.sharedId ? tree.addShadowElement(rootElem.sharedId, newTree) : tree.addShadowElement(newTree);
      return;
    }
    if (eventType === "removeShadowRoot" && args[2].type === "node" && args[2].sharedId) {
      const tree = this.#shadowRoots.get(logEntry.source.context);
      if (!tree) {
        return;
      }
      return tree.remove(args[2].sharedId);
    }
    throw new Error(`Invalid parameters for "${eventType}" event: ${args.join(", ")}`);
  }
  getShadowElementsByContextId(contextId, scope) {
    let tree = this.#shadowRoots.get(contextId);
    if (!tree) {
      return [];
    }
    if (scope) {
      const subTree = tree.find(scope);
      if (subTree) {
        tree = subTree;
      }
    }
    return tree.getAllLookupScopes();
  }
  getShadowElementPairsByContextId(contextId, scope) {
    let tree = this.#shadowRoots.get(contextId);
    if (!tree) {
      return [];
    }
    if (scope) {
      const subTree = tree.find(scope);
      if (subTree) {
        tree = subTree;
      }
    }
    return tree.flat().map((tree2) => [tree2.element, tree2.shadowRoot]);
  }
  getShadowRootModeById(contextId, element) {
    const tree = this.#shadowRoots.get(contextId);
    if (!tree) {
      return;
    }
    const shadowTree = tree.find(element);
    if (!shadowTree) {
      return;
    }
    return shadowTree.mode;
  }
  deleteShadowRoot(element, contextId) {
    const tree = this.#shadowRoots.get(contextId);
    if (!tree) {
      return;
    }
    return tree.remove(element);
  }
};
var ShadowRootTree = class _ShadowRootTree {
  element;
  shadowRoot;
  mode;
  children = /* @__PURE__ */ new Set();
  constructor(element, shadowRoot, mode) {
    this.element = element;
    this.shadowRoot = shadowRoot;
    this.mode = mode;
  }
  addShadowElement(...args) {
    const [scope, treeArg] = args;
    if (!scope && !treeArg) {
      throw new Error('Method "addShadowElement" expects at least 2 arguments');
    }
    if (scope instanceof _ShadowRootTree) {
      this.children.add(scope);
      return;
    }
    if (typeof scope === "string" && treeArg instanceof _ShadowRootTree) {
      const tree = this.find(scope) || this.findByShadowId(scope);
      if (!tree) {
        throw new Error(`Couldn't find element with id ${scope}`);
      }
      tree.addShadowElement(treeArg);
      return;
    }
    throw new Error('Invalid arguments for "addShadowElement" method');
  }
  find(element) {
    if (this.element === element) {
      return this;
    }
    for (const child of this.children) {
      const elem = child.find(element);
      if (elem) {
        return elem;
      }
    }
    return void 0;
  }
  findByShadowId(shadowRoot) {
    if (this.shadowRoot === shadowRoot) {
      return this;
    }
    for (const child of this.children) {
      const elem = child.findByShadowId(shadowRoot);
      if (elem) {
        return elem;
      }
    }
    return void 0;
  }
  getAllLookupScopes() {
    return [
      this.shadowRoot ?? this.element,
      ...Array.from(this.children).map((tree) => tree.getAllLookupScopes())
    ].flat();
  }
  flat() {
    return [this, ...Array.from(this.children).map((tree) => tree.flat())].flat();
  }
  remove(element) {
    for (const child of this.children) {
      if (child.element === element) {
        return this.children.delete(child);
      }
      const wasFound = child.remove(element);
      if (wasFound) {
        return true;
      }
    }
    return false;
  }
};

// src/commands/element/getHTML.ts
import getHTMLScript from "./scripts/getHTML.js";
import getHTMLShadowScript from "./scripts/getHTMLShadow.js";
var SHADOW_ID_ATTR_NAME = "data-wdio-shadow-id";
var SHADOW_ID_ATTR = `[${SHADOW_ID_ATTR_NAME}]`;
async function getHTML(options = {}) {
  const browser = getBrowserObject19(this);
  if (typeof options !== "object" && typeof options === "boolean") {
    options = { includeSelectorTag: options };
  } else if (typeof options !== "object") {
    throw new Error("The `getHTML` options parameter must be an object");
  }
  const { includeSelectorTag, pierceShadowRoot, removeCommentNodes, prettify, excludeElements } = Object.assign({
    includeSelectorTag: true,
    pierceShadowRoot: true,
    removeCommentNodes: true,
    prettify: true,
    excludeElements: []
  }, options);
  const basicGetHTML = (elementId, includeSelectorTag2) => {
    return browser.execute(getHTMLScript, {
      [ELEMENT_KEY11]: elementId,
      // w3c compatible
      ELEMENT: elementId
      // jsonwp compatible
    }, includeSelectorTag2);
  };
  if (pierceShadowRoot && this.isBidi) {
    if (globalThis.wdio) {
      return globalThis.wdio.executeWithScope(
        "getHTML",
        this.elementId,
        { includeSelectorTag, pierceShadowRoot, removeCommentNodes, prettify }
      );
    }
    const { load } = await import("cheerio");
    const shadowRootManager2 = getShadowRootManager(browser);
    const contextManager2 = getContextManager(browser);
    const context = await contextManager2.getCurrentContext();
    const shadowRootElementPairs = shadowRootManager2.getShadowElementPairsByContextId(context, this.elementId);
    const elementsWithShadowRootAndIdVerified = (await Promise.all(
      shadowRootElementPairs.map(([elemId, elem]) => browser.execute((elem2) => elem2.tagName, { [ELEMENT_KEY11]: elemId }).then(
        () => [elemId, elem],
        () => void 0
      ))
    )).filter(Boolean).map(([elemId, shadowId]) => [
      elemId,
      { [ELEMENT_KEY11]: elemId },
      shadowId ? { [ELEMENT_KEY11]: shadowId } : void 0
    ]);
    const { html, shadowElementHTML } = await browser.execute(
      getHTMLShadowScript,
      { [ELEMENT_KEY11]: this.elementId },
      includeSelectorTag,
      elementsWithShadowRootAndIdVerified
    );
    const $3 = load(html);
    populateHTML($3, shadowElementHTML.map(({ id, ...props }) => ({
      ...props,
      id,
      mode: shadowRootManager2.getShadowRootModeById(context, id) || "open"
    })));
    return sanitizeHTML($3, { removeCommentNodes, prettify, excludeElements });
  }
  const returnHTML = await basicGetHTML(this.elementId, includeSelectorTag);
  return sanitizeHTML(returnHTML, { removeCommentNodes, prettify });
}
function populateHTML($3, shadowElementHTML) {
  const shadowElements = $3(SHADOW_ID_ATTR);
  if (shadowElements.length === 0) {
    return;
  }
  for (const elem of shadowElements) {
    const id = elem.attribs[SHADOW_ID_ATTR_NAME];
    const shadowReference = shadowElementHTML.find(({ id: shadowRootId }) => id === shadowRootId);
    if (!shadowReference) {
      continue;
    }
    $3(`[${SHADOW_ID_ATTR_NAME}="${id}"]`).append([
      `<template shadowrootmode="${shadowReference.mode}">`,
      shadowReference.styles && shadowReference.styles.length > 0 ? `	<style>${shadowReference.styles.join("\n")}</style>` : "",
      `	${shadowReference.html}`,
      "</template>"
    ].join("\n"));
    delete elem.attribs[SHADOW_ID_ATTR_NAME];
  }
  populateHTML($3, shadowElementHTML);
}
function sanitizeHTML($3, options = {}) {
  const isCheerioObject = $3 && typeof $3 !== "string";
  if (isCheerioObject) {
    for (const elemToRemove of options.excludeElements || []) {
      $3(elemToRemove).remove();
    }
  }
  let returnHTML = isCheerioObject ? $3("body").html() : $3;
  if (options.removeCommentNodes) {
    returnHTML = returnHTML?.replace(/<!--[\s\S]*?-->/g, "");
  }
  return options.prettify ? prettifyFn(returnHTML) : returnHTML;
}

// src/commands/element/getLocation.ts
async function getLocation(prop) {
  let location = {};
  location = await getElementRect(this);
  delete location.width;
  delete location.height;
  if (prop === "x" || prop === "y") {
    return location[prop];
  }
  return location;
}

// src/commands/element/getProperty.ts
function getProperty(property) {
  return this.getElementProperty(this.elementId, property);
}

// src/commands/element/getSize.ts
async function getSize(prop) {
  const rect = await getElementRect(this);
  if (prop && typeof rect[prop] === "number") {
    return rect[prop];
  }
  return {
    width: rect.width,
    height: rect.height
  };
}

// src/commands/element/getTagName.ts
function getTagName() {
  return this.getElementTagName(this.elementId);
}

// src/commands/element/getText.ts
function getText() {
  return this.getElementText(this.elementId);
}

// src/commands/element/getValue.ts
function getValue() {
  if (this.isW3C && !this.isMobile) {
    return this.getElementProperty(this.elementId, "value");
  }
  return this.getElementAttribute(this.elementId, "value");
}

// src/commands/element/isClickable.ts
import { ELEMENT_KEY as ELEMENT_KEY12 } from "webdriver";
import { getBrowserObject as getBrowserObject20 } from "@wdio/utils";
import isElementClickableScript from "./scripts/isElementClickable.js";
async function isClickable() {
  if (!await this.isDisplayed()) {
    return false;
  }
  if (this.isMobile && await this.getContext().catch(() => void 0) === "NATIVE_APP") {
    throw new Error("Method not supported in mobile native environment. It is unlikely that you need to use this command.");
  }
  const browser = getBrowserObject20(this);
  return browser.execute(isElementClickableScript, {
    [ELEMENT_KEY12]: this.elementId,
    // w3c compatible
    ELEMENT: this.elementId
    // jsonwp compatible
  });
}

// src/commands/element/isDisplayed.ts
import { getBrowserObject as getBrowserObject21 } from "@wdio/utils";
import isElementDisplayedScript from "./scripts/isElementDisplayed.js";
import isElementInViewportScript from "./scripts/isElementInViewport.js";
async function isDisplayed(commandParams = { withinViewport: false }) {
  const browser = getBrowserObject21(this);
  if (!await hasElementId(this)) {
    return false;
  }
  const isNativeApplication = !browser.capabilities.browserName;
  if (browser.isMobile && isNativeApplication) {
    if (commandParams?.withinViewport) {
      throw new Error(
        "Cannot determine element visibility within viewport for native mobile apps as it is not feasible to determine full vertical and horizontal application bounds. In most cases a basic visibility check should suffice."
      );
    }
    return await this.isElementDisplayed(this.elementId);
  }
  const isDisplayed2 = await browser.execute(isElementDisplayedScript, this);
  if (isDisplayed2 && commandParams?.withinViewport) {
    return browser.execute(isElementInViewportScript, this);
  }
  return isDisplayed2;
}

// src/commands/element/isEnabled.ts
function isEnabled() {
  return this.isElementEnabled(this.elementId);
}

// src/commands/element/isEqual.ts
import { ELEMENT_KEY as ELEMENT_KEY13 } from "webdriver";
import { getBrowserObject as getBrowserObject22 } from "@wdio/utils";
var getWebElement = (el) => ({
  [ELEMENT_KEY13]: el.elementId,
  // w3c compatible
  ELEMENT: el.elementId
  // jsonwp compatible
});
async function isEqual(el) {
  const browser = getBrowserObject22(this);
  if (browser.isMobile) {
    const context = await browser.getContext().catch(() => void 0);
    const contextId = typeof context === "string" ? context : context?.id;
    if (contextId && contextId.toLowerCase().includes("native")) {
      return this.elementId === el.elementId;
    }
  }
  let result;
  try {
    result = await browser.execute(
      /* istanbul ignore next */
      function(el1, el2) {
        return el1 === el2;
      },
      getWebElement(this),
      getWebElement(el)
    );
  } catch (err) {
    result = false;
  }
  return result;
}

// src/commands/element/isExisting.ts
async function isExisting() {
  if (!this.selector) {
    return this.getElementTagName(this.elementId).then(
      () => true,
      () => false
    );
  }
  const command = this.isReactElement ? this.parent.react$$.bind(this.parent) : this.isShadowElement ? this.shadow$$.bind(this.parent) : this.parent.$$.bind(this.parent);
  return command(this.selector).getElements().then((res) => res.length > 0);
}

// src/commands/element/isFocused.ts
import { ELEMENT_KEY as ELEMENT_KEY14 } from "webdriver";
import { getBrowserObject as getBrowserObject23 } from "@wdio/utils";
import isFocusedScript from "./scripts/isFocused.js";
async function isFocused() {
  const browser = await getBrowserObject23(this);
  return browser.execute(isFocusedScript, {
    [ELEMENT_KEY14]: this.elementId,
    // w3c compatible
    ELEMENT: this.elementId
    // jsonwp compatible
  });
}

// src/commands/element/isSelected.ts
function isSelected() {
  return this.isElementSelected(this.elementId);
}

// src/commands/element/isStable.ts
import { ELEMENT_KEY as ELEMENT_KEY15 } from "webdriver";
import { getBrowserObject as getBrowserObject24 } from "@wdio/utils";
import isElementStable from "./scripts/isElementStable.js";
async function isStable() {
  const browser = getBrowserObject24(this);
  return await browser.executeAsync(isElementStable, {
    [ELEMENT_KEY15]: this.elementId,
    // w3c compatible
    ELEMENT: this.elementId
    // jsonwp compatible
  });
}

// src/commands/element/moveTo.ts
import logger14 from "@wdio/logger";
import { getBrowserObject as getBrowserObject25 } from "@wdio/utils";
var log14 = logger14("webdriver");
async function moveTo({ xOffset, yOffset } = {}) {
  const browser = getBrowserObject25(this);
  if (xOffset || yOffset) {
    const { width, height } = await browser.getElementRect(this.elementId);
    if (xOffset && xOffset < -Math.floor(width / 2) || xOffset && xOffset > Math.floor(width / 2)) {
      log14.warn("xOffset would cause a out of bounds error as it goes outside of element");
    }
    if (yOffset && yOffset < -Math.floor(height / 2) || yOffset && yOffset > Math.floor(height / 2)) {
      log14.warn("yOffset would cause a out of bounds error as it goes outside of element");
    }
  }
  const moveToNested = async () => {
    await browser.action("pointer", { parameters: { pointerType: "mouse" } }).move({ origin: this, x: xOffset || 0, y: yOffset || 0 }).perform();
  };
  try {
    await moveToNested();
  } catch {
    await this.scrollIntoView({ block: "center", inline: "center" });
    await moveToNested();
  }
}

// src/commands/element/nextElement.ts
function nextElement() {
  return this.$(
    /* istanbul ignore next */
    function nextElement2() {
      return this.nextElementSibling;
    }
  );
}

// src/commands/element/parentElement.ts
function parentElement() {
  return this.$(
    /* istanbul ignore next */
    function parentElement2() {
      return this.parentElement;
    }
  );
}

// src/commands/element/previousElement.ts
function previousElement() {
  return this.$(
    /* istanbul ignore next */
    function previousElement2() {
      return this.previousElementSibling;
    }
  );
}

// src/commands/element/react$$.ts
import fs8 from "node:fs/promises";
import url4 from "node:url";
import { resolve as resolve3 } from "import-meta-resolve";
import { getBrowserObject as getBrowserObject26 } from "@wdio/utils";
import { waitToLoadReact as waitToLoadReact3, react$$ as react$$Script2 } from "./scripts/resq.js";
var resqScript3;
async function react$$2(selector, { props = {}, state = {} } = {}) {
  if (!resqScript3) {
    const resqScriptPath = url4.fileURLToPath(await resolve3("resq", import.meta.url));
    resqScript3 = (await fs8.readFile(resqScriptPath)).toString();
  }
  const browser = await getBrowserObject26(this);
  await this.executeScript(resqScript3.toString(), []);
  await browser.execute(waitToLoadReact3);
  const res = await browser.execute(
    react$$Script2,
    selector,
    props,
    state,
    this
  );
  const elements = await getElements.call(this, selector, res, { isReactElement: true });
  return enhanceElementsArray(elements, this, selector, "react$$", [props, state]);
}

// src/commands/element/react$.ts
import fs9 from "node:fs/promises";
import url5 from "node:url";
import { resolve as resolve4 } from "import-meta-resolve";
import { getBrowserObject as getBrowserObject27 } from "@wdio/utils";
import { waitToLoadReact as waitToLoadReact4, react$ as react$Script2 } from "./scripts/resq.js";
var resqScript4;
async function react$2(selector, { props = {}, state = {} } = {}) {
  if (!resqScript4) {
    const resqScriptPath = url5.fileURLToPath(await resolve4("resq", import.meta.url));
    resqScript4 = (await fs9.readFile(resqScriptPath)).toString();
  }
  const browser = await getBrowserObject27(this);
  await this.executeScript(resqScript4.toString(), []);
  await browser.execute(waitToLoadReact4);
  const res = await browser.execute(
    react$Script2,
    selector,
    props,
    state,
    this
  );
  return getElement.call(this, selector, res, { isReactElement: true });
}

// src/commands/element/saveScreenshot.ts
import fs10 from "node:fs/promises";
async function saveScreenshot2(filepath) {
  if (typeof filepath !== "string" || !filepath.endsWith(".png")) {
    throw new Error('saveScreenshot expects a filepath of type string and ".png" file ending');
  }
  const absoluteFilepath = getAbsoluteFilepath(filepath);
  await assertDirectoryExists(absoluteFilepath);
  const screenBuffer = await this.takeElementScreenshot(this.elementId);
  const screenshot = Buffer.from(screenBuffer, "base64");
  await fs10.writeFile(absoluteFilepath, screenshot);
  return screenshot;
}

// src/commands/element/scrollIntoView.ts
import logger15 from "@wdio/logger";
import { ELEMENT_KEY as ELEMENT_KEY16 } from "webdriver";
import { getBrowserObject as getBrowserObject28 } from "@wdio/utils";
var log15 = logger15("webdriverio");
function scrollIntoViewWeb(options = { block: "start", inline: "nearest" }) {
  const browser = getBrowserObject28(this);
  return browser.execute(
    (elem, options2) => elem.scrollIntoView(options2),
    {
      [ELEMENT_KEY16]: this.elementId,
      // w3c compatible
      ELEMENT: this.elementId
      // jsonwp compatible
    },
    options
  );
}
async function scrollIntoView(options = { block: "start", inline: "nearest" }) {
  const browser = getBrowserObject28(this);
  if (browser.isMobile) {
    return scrollIntoViewWeb.call(this, options);
  }
  try {
    const elemRect = await browser.getElementRect(this.elementId);
    const viewport = await browser.getWindowSize();
    let [scrollX, scrollY] = await browser.execute(() => [
      window.scrollX,
      window.scrollY
    ]);
    scrollX = elemRect.x <= viewport.width ? elemRect.x : viewport.width / 2;
    scrollY = elemRect.y <= viewport.height ? elemRect.y : viewport.height / 2;
    const deltaByOption = {
      start: { y: elemRect.y - elemRect.height, x: elemRect.x - elemRect.width },
      center: { y: elemRect.y - Math.round((viewport.height - elemRect.height) / 2), x: elemRect.x - Math.round((viewport.width - elemRect.width) / 2) },
      end: { y: elemRect.y - (viewport.height - elemRect.height), x: elemRect.x - (viewport.width - elemRect.width) }
    };
    let [deltaX, deltaY] = [deltaByOption.start.x, deltaByOption.start.y];
    if (options === true) {
      options = { block: "start", inline: "nearest" };
    }
    if (options === false) {
      options = { block: "end", inline: "nearest" };
    }
    if (options && typeof options === "object") {
      const { block, inline } = options;
      if (block === "nearest") {
        const nearestYDistance = Math.min(...Object.values(deltaByOption).map((delta) => delta.y));
        deltaY = Object.values(deltaByOption).find((delta) => delta.y === nearestYDistance).y;
      } else if (block) {
        deltaY = deltaByOption[block].y;
      }
      if (inline === "nearest") {
        const nearestXDistance = Math.min(...Object.values(deltaByOption).map((delta) => delta.x));
        deltaX = Object.values(deltaByOption).find((delta) => delta.x === nearestXDistance).x;
      } else if (inline) {
        deltaX = deltaByOption[inline].x;
      }
    }
    deltaX = Math.round(deltaX - scrollX);
    deltaY = Math.round(deltaY - scrollY);
    await browser.action("wheel").scroll({ duration: 0, x: deltaX, y: deltaY, origin: this }).perform();
  } catch (err) {
    log15.warn(
      `Failed to execute "scrollIntoView" using WebDriver Actions API: ${err.message}!
Re-attempting using \`Element.scrollIntoView\` via Web API.`
    );
    await scrollIntoViewWeb.call(this, options);
  }
}

// src/commands/element/selectByAttribute.ts
async function selectByAttribute(attribute, value) {
  value = typeof value === "number" ? value.toString() : value;
  const normalized = `[normalize-space(@${attribute.trim()}) = "${value.trim()}"]`;
  const optionElement = await this.findElementFromElement(
    this.elementId,
    "xpath",
    `./option${normalized}|./optgroup/option${normalized}`
  );
  if (optionElement && optionElement.error === "no such element") {
    throw new Error(`Option with attribute "${attribute}=${value}" not found.`);
  }
  return this.elementClick(getElementFromResponse(optionElement));
}

// src/commands/element/selectByIndex.ts
async function selectByIndex(index) {
  if (index < 0) {
    throw new Error("Index needs to be 0 or any other positive number");
  }
  const optionElements = await this.findElementsFromElement(this.elementId, "css selector", "option");
  if (optionElements.length === 0) {
    throw new Error("Select element doesn't contain any option element");
  }
  if (optionElements.length - 1 < index) {
    throw new Error(`Option with index "${index}" not found. Select element only contains ${optionElements.length} option elements`);
  }
  return this.elementClick(getElementFromResponse(optionElements[index]));
}

// src/commands/element/selectByVisibleText.ts
async function selectByVisibleText(text) {
  text = typeof text === "number" ? text.toString() : text;
  const normalized = text.trim().replace(/\s+/, " ");
  const formatted = /"/.test(normalized) ? 'concat("' + normalized.split('"').join(`", '"', "`) + '")' : `"${normalized}"`;
  const dotFormat = `[. = ${formatted}]`;
  const spaceFormat = `[normalize-space(text()) = ${formatted}]`;
  const selections = [
    `./option${dotFormat}`,
    `./option${spaceFormat}`,
    `./optgroup/option${dotFormat}`,
    `./optgroup/option${spaceFormat}`
  ];
  const optionElement = await this.findElementFromElement(this.elementId, "xpath", selections.join("|"));
  if (optionElement && optionElement.error === "no such element") {
    throw new Error(`Option with text "${text}" not found.`);
  }
  return this.elementClick(getElementFromResponse(optionElement));
}

// src/commands/element/setValue.ts
async function setValue(value) {
  await this.clearValue();
  return this.addValue(value);
}

// src/commands/element/shadow$$.ts
import logger16 from "@wdio/logger";
import { getBrowserObject as getBrowserObject29 } from "@wdio/utils";
import { SHADOW_ELEMENT_KEY } from "webdriver";
import { shadowFnFactory } from "./scripts/shadowFnFactory.js";

// src/utils/findStrategy.ts
import fs11 from "node:fs";
import { roleElements } from "aria-query";
var DEFAULT_STRATEGY = "css selector";
var DIRECT_SELECTOR_REGEXP = /^(id|css selector|xpath|link text|partial link text|name|tag name|class name|-android uiautomator|-android datamatcher|-android viewmatcher|-android viewtag|-ios uiautomation|-ios predicate string|-ios class chain|accessibility id):(.+)/;
var XPATH_SELECTORS_START = [
  "/",
  "(",
  "../",
  "./",
  "*/"
];
var NAME_MOBILE_SELECTORS_START = [
  "uia",
  "xcuielementtype",
  "android.widget",
  "cyi",
  "android.view"
];
var XPATH_SELECTOR_REGEXP = [
  // HTML tag
  /^([a-z0-9|-]*)/,
  // optional . or # + class or id
  /(?:(\.|#)(-?[_a-zA-Z]+[_a-zA-Z0-9-]*))?/,
  // optional [attribute-name="attribute-selector"]
  /(?:\[(-?[_a-zA-Z]+[_a-zA-Z0-9-]*)(?:=(?:"|')([a-zA-z0-9\-_. ]+)(?:"|'))?\])?/,
  // optional case insensitive
  /(\.)?/,
  // *=query or =query
  /(\*)?=(.+)$/
];
var IMAGEPATH_MOBILE_SELECTORS_ENDSWITH = [
  ".jpg",
  ".jpeg",
  ".gif",
  ".png",
  ".bmp",
  ".svg"
];
var defineStrategy = function(selector) {
  if (typeof selector === "object") {
    if (JSON.stringify(selector).indexOf("test.espresso.matcher.ViewMatchers") < 0) {
      return "-android datamatcher";
    }
    return "-android viewmatcher";
  }
  const stringSelector = selector;
  if (stringSelector.match(DIRECT_SELECTOR_REGEXP)) {
    return "directly";
  }
  if (IMAGEPATH_MOBILE_SELECTORS_ENDSWITH.some((path4) => {
    const selector2 = stringSelector.toLowerCase();
    return selector2.endsWith(path4) && selector2 !== path4;
  })) {
    return "-image";
  }
  if (XPATH_SELECTORS_START.some((option) => stringSelector.startsWith(option))) {
    return "xpath";
  }
  if (stringSelector.startsWith("=")) {
    return "link text";
  }
  if (stringSelector.startsWith("*=")) {
    return "partial link text";
  }
  if (stringSelector.startsWith("id=")) {
    return "id";
  }
  if (stringSelector.startsWith(DEEP_SELECTOR)) {
    return "shadow";
  }
  if (stringSelector.startsWith(ARIA_SELECTOR)) {
    return "aria";
  }
  if (stringSelector.startsWith("android=")) {
    return "-android uiautomator";
  }
  if (stringSelector.startsWith("ios=")) {
    return "-ios uiautomation";
  }
  if (stringSelector.startsWith("~")) {
    return "accessibility id";
  }
  if (NAME_MOBILE_SELECTORS_START.some((option) => stringSelector.toLowerCase().startsWith(option))) {
    return "class name";
  }
  if (stringSelector.search(/<[0-9a-zA-Z-]+( \/)*>/g) >= 0) {
    return "tag name";
  }
  if (stringSelector.search(/^\[name=(?:"(.[^"]*)"|'(.[^']*)')]$/) >= 0) {
    return "name";
  }
  if (selector === ".." || selector === ".") {
    return "xpath";
  }
  if (stringSelector.match(new RegExp(XPATH_SELECTOR_REGEXP.map((rx) => rx.source).join("")))) {
    return "xpath extended";
  }
  if (stringSelector.match(/^\[role=[A-Za-z]+]$/)) {
    return "role";
  }
};
var findStrategy = function(selector, isW3C, isMobile) {
  const stringSelector = selector;
  let using = DEFAULT_STRATEGY;
  let value = selector;
  switch (defineStrategy(selector)) {
    case "directly": {
      const match = stringSelector.match(DIRECT_SELECTOR_REGEXP);
      if (!match) {
        throw new Error("InvalidSelectorStrategy");
      }
      using = match[1];
      value = match[2];
      break;
    }
    case "xpath": {
      using = "xpath";
      break;
    }
    case "id": {
      using = "id";
      value = stringSelector.slice(3);
      break;
    }
    case "link text": {
      using = "link text";
      value = stringSelector.slice(1);
      break;
    }
    case "partial link text": {
      using = "partial link text";
      value = stringSelector.slice(2);
      break;
    }
    case "shadow":
      using = "shadow";
      value = stringSelector.slice(DEEP_SELECTOR.length);
      break;
    case "aria": {
      const label = stringSelector.slice(ARIA_SELECTOR.length);
      const conditions = [
        // aria label is recevied by other element with aria-labelledBy
        // https://www.w3.org/TR/accname-1.1/#step2B
        `.//*[@aria-labelledby=(//*[normalize-space(text()) = "${label}"]/@id)]`,
        // aria label is recevied by other element with aria-labelledBy
        // https://www.w3.org/TR/accname-1.1/#step2B
        `.//*[@aria-describedby=(//*[normalize-space(text()) = "${label}"]/@id)]`,
        // element has direct aria label
        // https://www.w3.org/TR/accname-1.1/#step2C
        `.//*[@aria-label = "${label}"]`,
        // input and textarea with a label
        // https://www.w3.org/TR/accname-1.1/#step2D
        `.//input[@id = (//label[normalize-space() = "${label}"]/@for)]`,
        `.//textarea[@id = (//label[normalize-space() = "${label}"]/@for)]`,
        // input and textarea with a label as parent
        // https://www.w3.org/TR/accname-1.1/#step2D
        `.//input[ancestor::label[normalize-space(text()) = "${label}"]]`,
        `.//textarea[ancestor::label[normalize-space(text()) = "${label}"]]`,
        // aria label is received by a placeholder
        // https://www.w3.org/TR/accname-1.1/#step2D
        `.//input[@placeholder="${label}"]`,
        `.//textarea[@placeholder="${label}"]`,
        // aria label is received by a aria-placeholder
        // https://www.w3.org/TR/accname-1.1/#step2D
        `.//input[@aria-placeholder="${label}"]`,
        `.//textarea[@aria-placeholder="${label}"]`,
        // aria label is received by a title
        // https://www.w3.org/TR/accname-1.1/#step2D
        `.//*[not(self::label)][@title="${label}"]`,
        // images with an alt tag
        // https://www.w3.org/TR/accname-1.1/#step2D
        `.//img[@alt="${label}"]`,
        // aria label is received from element text content
        // https://www.w3.org/TR/accname-1.1/#step2G
        `.//*[not(self::label)][normalize-space(text()) = "${label}"]`
      ];
      using = "xpath";
      value = conditions.join(" | ");
      break;
    }
    case "-android uiautomator": {
      using = "-android uiautomator";
      value = stringSelector.slice(8);
      break;
    }
    case "-android datamatcher": {
      using = "-android datamatcher";
      value = JSON.stringify(value);
      break;
    }
    case "-android viewmatcher": {
      using = "-android viewmatcher";
      value = JSON.stringify(value);
      break;
    }
    case "-ios uiautomation": {
      using = "-ios uiautomation";
      value = stringSelector.slice(4);
      break;
    }
    case "accessibility id": {
      using = "accessibility id";
      value = stringSelector.slice(1);
      break;
    }
    case "class name": {
      using = "class name";
      break;
    }
    case "tag name": {
      using = "tag name";
      value = stringSelector.replace(/<|>|\/|\s/g, "");
      break;
    }
    case "name": {
      if (isMobile || !isW3C) {
        const match = stringSelector.match(/^\[name=(?:"(.[^"]*)"|'(.[^']*)')]$/);
        if (!match) {
          throw new Error(`InvalidSelectorMatch. Strategy 'name' has failed to match '${stringSelector}'`);
        }
        using = "name";
        value = match[1] || match[2];
      }
      break;
    }
    case "xpath extended": {
      using = "xpath";
      const match = stringSelector.match(new RegExp(XPATH_SELECTOR_REGEXP.map((rx) => rx.source).join("")));
      if (!match) {
        throw new Error(`InvalidSelectorMatch: Strategy 'xpath extended' has failed to match '${stringSelector}'`);
      }
      const PREFIX_NAME = { ".": "class", "#": "id" };
      const conditions = [];
      const [
        tag,
        prefix,
        name,
        attrName,
        attrValue,
        insensitive,
        partial,
        query
      ] = match.slice(1);
      if (prefix) {
        if (prefix === ".") {
          conditions.push(`contains(concat(" ",@${PREFIX_NAME[prefix]}," "), " ${name} ")`);
        } else {
          conditions.push(`contains(@${PREFIX_NAME[prefix]}, "${name}")`);
        }
      }
      if (attrName) {
        conditions.push(
          attrValue ? `contains(@${attrName}, "${attrValue}")` : `@${attrName}`
        );
      }
      const partialNot = ` and not(${`.//${tag || "*"}${conditions.length ? `[${conditions.join(" and ")}]` : ""}`})`;
      if (insensitive) {
        conditions.push(
          partial ? `contains(translate(., "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz"), "${query.toLowerCase()}")${partialNot}` : `normalize-space(translate(text(), "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz")) = "${query.toLowerCase()}"`
        );
      } else {
        conditions.push(partial ? `contains(., "${query}")${partialNot}` : `normalize-space(text()) = "${query}"`);
      }
      const getValue2 = () => `.//${tag || "*"}[${conditions.join(" and ")}]`;
      value = getValue2();
      if (!partial) {
        conditions.pop();
        conditions.push(
          `not(${value})`,
          `normalize-space() = "${insensitive ? query.toLowerCase() : query}"`
        );
        value = value + " | " + getValue2();
      }
      break;
    }
    case "-image": {
      using = "-image";
      value = fs11.readFileSync(stringSelector, { encoding: "base64" });
      break;
    }
    case "role": {
      const match = stringSelector.match(/^\[role=(.+)\]/);
      if (!match) {
        throw new Error(`InvalidSelectorMatch. Strategy 'role' has failed to match '${stringSelector}'`);
      }
      using = "css selector";
      value = createRoleBaseXpathSelector(match[1]);
      break;
    }
  }
  return { using, value };
};
var createRoleBaseXpathSelector = (role) => {
  const locatorArr = [];
  roleElements.get(role)?.forEach((value) => {
    let locator;
    let tagAttribute, tagAttributevalue;
    const tagname = value.name;
    if (value.attributes instanceof Array) {
      value.attributes.forEach((val) => {
        tagAttribute = val.name;
        tagAttributevalue = val.value;
      });
    }
    if (!tagAttribute) {
      locator = tagname;
    } else if (!tagAttributevalue) {
      locator = `${tagname}[${tagAttribute}]`;
    } else {
      locator = `${tagname}[${tagAttribute}="${tagAttributevalue}"]`;
    }
    locatorArr.push(locator);
  });
  let xpathLocator = `[role="${role}"]`;
  locatorArr.forEach((loc) => {
    xpathLocator += "," + loc;
  });
  return xpathLocator;
};

// src/commands/element/shadow$$.ts
var log16 = logger16("webdriverio");
async function shadow$$(selector) {
  const browser = getBrowserObject29(this);
  try {
    const shadowRoot = await browser.getElementShadowRoot(this.elementId);
    const { using, value } = findStrategy(selector, this.isW3C, this.isMobile);
    const res = await browser.findElementsFromShadowRoot(shadowRoot[SHADOW_ELEMENT_KEY], using, value);
    const elements = await getElements.call(this, selector, res, { isShadowElement: true });
    return enhanceElementsArray(elements, this, selector);
  } catch (err) {
    log16.warn(
      `Failed to fetch element within shadow DOM using WebDriver command: ${err.message}!
Falling back to JavaScript shim.`
    );
    return await this.$$(shadowFnFactory(selector, true));
  }
}

// src/commands/element/shadow$.ts
import logger17 from "@wdio/logger";
import { SHADOW_ELEMENT_KEY as SHADOW_ELEMENT_KEY2 } from "webdriver";
import { shadowFnFactory as shadowFnFactory2 } from "./scripts/shadowFnFactory.js";
import { getBrowserObject as getBrowserObject30 } from "@wdio/utils";
var log17 = logger17("webdriverio");
async function shadow$(selector) {
  const browser = getBrowserObject30(this);
  try {
    const shadowRoot = await browser.getElementShadowRoot(this.elementId);
    const { using, value } = findStrategy(selector, this.isW3C, this.isMobile);
    const res = await browser.findElementFromShadowRoot(shadowRoot[SHADOW_ELEMENT_KEY2], using, value);
    return getElement.call(this, selector, res, { isShadowElement: true });
  } catch (err) {
    log17.warn(
      `Failed to fetch element within shadow DOM using WebDriver command: ${err.message}!
Falling back to JavaScript shim.`
    );
    return this.$(shadowFnFactory2(selector));
  }
}

// src/commands/element/touchAction.ts
function touchAction3(actions2) {
  return touchAction.call(this, actions2);
}

// src/commands/element/waitForClickable.ts
async function waitForClickable({
  timeout = this.options.waitforTimeout,
  interval = this.options.waitforInterval,
  reverse = false,
  timeoutMsg = `element ("${this.selector}") still ${reverse ? "" : "not "}clickable after ${timeout}ms`
} = {}) {
  return this.waitUntil(
    async () => reverse !== await this.isClickable(),
    { timeout, timeoutMsg, interval }
  );
}

// src/commands/element/waitForDisplayed.ts
async function waitForDisplayed({
  timeout = this.options.waitforTimeout,
  interval = this.options.waitforInterval,
  reverse = false,
  withinViewport = false,
  timeoutMsg = `element ("${this.selector}") still ${reverse ? "" : "not "}displayed${withinViewport ? " within viewport" : ""} after ${timeout}ms`
} = {}) {
  return this.waitUntil(
    async () => reverse !== await this.isDisplayed({ withinViewport }),
    { timeout, interval, timeoutMsg }
  );
}

// src/commands/element/waitForEnabled.ts
async function waitForEnabled({
  timeout = this.options.waitforTimeout,
  interval = this.options.waitforInterval,
  reverse = false,
  timeoutMsg = `element ("${this.selector}") still ${reverse ? "" : "not "}enabled after ${timeout}ms`
} = {}) {
  if (!this.elementId && !reverse) {
    await this.waitForExist({ timeout, interval, timeoutMsg });
  }
  return this.waitUntil(
    async () => reverse !== await this.isEnabled(),
    { timeout, interval, timeoutMsg }
  );
}

// src/commands/element/waitForExist.ts
function waitForExist({
  timeout = this.options.waitforTimeout,
  interval = this.options.waitforInterval,
  reverse = false,
  timeoutMsg = `element ("${this.selector}") still ${reverse ? "" : "not "}existing after ${timeout}ms`
} = {}) {
  return this.waitUntil(
    async () => reverse !== await this.isExisting(),
    { timeout, interval, timeoutMsg }
  );
}

// src/commands/element/waitForStable.ts
async function waitForStable({
  timeout = this.options.waitforTimeout,
  interval = this.options.waitforInterval,
  reverse = false,
  timeoutMsg = `element ("${this.selector}") still ${reverse ? "" : "not "}stable after ${timeout}ms`
} = {}) {
  let errorMsg;
  await this.waitUntil(
    async () => {
      try {
        return reverse !== await this.isStable();
      } catch (error) {
        if (error instanceof Error) {
          errorMsg = error.message;
        } else if (typeof error === "string") {
          errorMsg = error;
        } else {
          errorMsg = "The waitForStable command got an unknown error";
        }
        return !reverse;
      }
    },
    { timeout, interval, timeoutMsg }
  );
  if (errorMsg) {
    throw Error(errorMsg);
  }
}

// src/commands/element/waitUntil.ts
var waitUntil2 = waitUntil;

// src/utils/index.ts
import elementContains from "./scripts/elementContains.js";

// src/utils/thirdParty/querySelectorShadowDom.ts
function querySelectorAllDeep(findMany, s, r) {
  function normalizeSelector(sel) {
    function saveUnmatched() {
      if (unmatched) {
        if (tokens.length > 0 && /^[~+>]$/.test(tokens[tokens.length - 1])) {
          tokens.push(" ");
        }
        tokens.push(unmatched);
      }
    }
    const tokens = [], state = [0], not_escaped_pattern = /(?:[^\\]|(?:^|[^\\])(?:\\\\)+)$/, whitespace_pattern = /^\s+$/, state_patterns = [
      /\s+|\/\*|["'>~+[(]/g,
      // general
      /\s+|\/\*|["'[\]()]/g,
      // [..] set
      /\s+|\/\*|["'[\]()]/g,
      // (..) set
      null,
      // string literal (placeholder)
      /\*\//g
      // comment
    ];
    let match, unmatched, regex, next_match_idx = 0, prev_match_idx;
    sel = sel.trim();
    while (true) {
      unmatched = "";
      regex = state_patterns[state[state.length - 1]];
      regex.lastIndex = next_match_idx;
      match = regex.exec(sel);
      if (match) {
        prev_match_idx = next_match_idx;
        next_match_idx = regex.lastIndex;
        if (prev_match_idx < next_match_idx - match[0].length) {
          unmatched = sel.substring(
            prev_match_idx,
            next_match_idx - match[0].length
          );
        }
        if (state[state.length - 1] < 3) {
          saveUnmatched();
          if (match[0] === "[") {
            state.push(1);
          } else if (match[0] === "(") {
            state.push(2);
          } else if (/^["']$/.test(match[0])) {
            state.push(3);
            state_patterns[3] = new RegExp(match[0], "g");
          } else if (match[0] === "/*") {
            state.push(4);
          } else if (/^[\])]$/.test(match[0]) && state.length > 0) {
            state.pop();
          } else if (/^(?:\s+|[~+>])$/.test(match[0])) {
            if (tokens.length > 0 && !whitespace_pattern.test(tokens[tokens.length - 1]) && state[state.length - 1] === 0) {
              tokens.push(" ");
            }
            if (state[state.length - 1] === 1 && tokens.length === 5 && tokens[2].charAt(tokens[2].length - 1) === "=") {
              tokens[4] = " " + tokens[4];
            }
            if (whitespace_pattern.test(match[0])) {
              continue;
            }
          }
          tokens.push(match[0]);
        } else {
          tokens[tokens.length - 1] += unmatched;
          if (not_escaped_pattern.test(tokens[tokens.length - 1])) {
            if (state[state.length - 1] === 4) {
              if (tokens.length < 2 || whitespace_pattern.test(tokens[tokens.length - 2])) {
                tokens.pop();
              } else {
                tokens[tokens.length - 1] = " ";
              }
              match[0] = "";
            }
            state.pop();
          }
          tokens[tokens.length - 1] += match[0];
        }
      } else {
        unmatched = sel.substr(next_match_idx);
        saveUnmatched();
        break;
      }
    }
    return tokens.join("").trim();
  }
  function _querySelectorDeep(selector, root, allElements = null) {
    selector = normalizeSelector(selector);
    const lightElement = root.querySelector(selector);
    if (document.head.createShadowRoot || document.head.attachShadow) {
      if (!findMany && lightElement) {
        return lightElement;
      }
      const selectionsToMake = splitByCharacterUnlessQuoted(selector, ",");
      return selectionsToMake.reduce((acc, minimalSelector) => {
        if (!findMany && acc) {
          return acc;
        }
        const splitSelector = splitByCharacterUnlessQuoted(minimalSelector.replace(/^\s+/g, "").replace(/\s*([>+~]+)\s*/g, "$1"), " ").filter((entry) => !!entry).map((entry) => splitByCharacterUnlessQuoted(entry, ">"));
        const possibleElementsIndex = splitSelector.length - 1;
        const lastSplitPart = splitSelector[possibleElementsIndex][splitSelector[possibleElementsIndex].length - 1];
        const possibleElements = collectAllElementsDeep(lastSplitPart, root, allElements);
        const findElements2 = findMatchingElement(splitSelector, possibleElementsIndex, root);
        if (findMany) {
          acc = acc.concat(possibleElements.filter(findElements2));
          return acc;
        }
        acc = possibleElements.find(findElements2);
        return acc || null;
      }, findMany ? [] : null);
    }
    return !findMany ? lightElement : root.querySelectorAll(selector);
  }
  function findMatchingElement(splitSelector, possibleElementsIndex, root) {
    return (element) => {
      let position = possibleElementsIndex;
      let parent = element;
      let foundElement = false;
      while (parent && !isDocumentNode(parent)) {
        let foundMatch = true;
        if (splitSelector[position].length === 1) {
          foundMatch = parent.matches(splitSelector[position]);
        } else {
          const reversedParts = [].concat(splitSelector[position]).reverse();
          let newParent = parent;
          for (const part of reversedParts) {
            if (!newParent || !newParent.matches(part)) {
              foundMatch = false;
              break;
            }
            newParent = findParentOrHost(newParent, root);
          }
        }
        if (foundMatch && position === 0) {
          foundElement = true;
          break;
        }
        if (foundMatch) {
          position--;
        }
        parent = findParentOrHost(parent, root);
      }
      return foundElement;
    };
  }
  function splitByCharacterUnlessQuoted(selector, character) {
    return selector.match(/\\?.|^$/g).reduce((p, c) => {
      if (c === '"' && !p.sQuote) {
        p.quote ^= 1;
        p.a[p.a.length - 1] += c;
      } else if (c === "'" && !p.quote) {
        p.sQuote ^= 1;
        p.a[p.a.length - 1] += c;
      } else if (!p.quote && !p.sQuote && c === character) {
        p.a.push("");
      } else {
        p.a[p.a.length - 1] += c;
      }
      return p;
    }, { a: [""] }).a;
  }
  function isDocumentNode(node) {
    return node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.DOCUMENT_NODE;
  }
  function findParentOrHost(element, root) {
    const parentNode = element.parentNode;
    return parentNode && parentNode.host && parentNode.nodeType === 11 ? parentNode.host : parentNode === root ? null : parentNode;
  }
  function collectAllElementsDeep(selector = null, root, cachedElements = null) {
    let allElements = [];
    if (cachedElements) {
      allElements = cachedElements;
    } else {
      const findAllElements = function(nodes) {
        for (let i = 0; i < nodes.length; i++) {
          const el = nodes[i];
          allElements.push(el);
          if (el.shadowRoot) {
            findAllElements(el.shadowRoot.querySelectorAll("*"));
          }
        }
      };
      if (root.shadowRoot) {
        findAllElements(root.shadowRoot?.querySelectorAll("*"));
      }
      findAllElements(root.querySelectorAll("*"));
    }
    return selector ? allElements.filter((el) => el.matches(selector)) : allElements;
  }
  return _querySelectorDeep(s, r || document);
}

// src/utils/index.ts
var log18 = logger18("webdriverio");
var INVALID_SELECTOR_ERROR = "selector needs to be typeof `string` or `function`";
var IGNORED_COMMAND_FILE_EXPORTS = ["SESSION_MOCKS", "CDP_SESSIONS"];
var scopes = {
  browser: browser_exports,
  element: element_exports
};
var applyScopePrototype = (prototype, scope) => {
  Object.entries(scopes[scope]).filter(([exportName]) => !IGNORED_COMMAND_FILE_EXPORTS.includes(exportName)).forEach(([commandName, command]) => {
    prototype[commandName] = { value: command };
  });
};
var getPrototype = (scope) => {
  const prototype = {
    /**
     * used to store the puppeteer instance in the browser scope
     */
    puppeteer: { value: null, writable: true }
  };
  applyScopePrototype(prototype, scope);
  prototype.strategies = { value: /* @__PURE__ */ new Map() };
  return prototype;
};
var getElementFromResponse = (res) => {
  if (!res) {
    return null;
  }
  if (res.ELEMENT) {
    return res.ELEMENT;
  }
  if (res[ELEMENT_KEY17]) {
    return res[ELEMENT_KEY17];
  }
  return null;
};
function sanitizeCSS(value) {
  if (!value) {
    return value;
  }
  return value.trim().replace(/'/g, "").replace(/"/g, "").toLowerCase();
}
function parseCSS(cssPropertyValue, cssProperty) {
  const parsedValue = {
    property: cssProperty,
    value: cssPropertyValue.toLowerCase().trim(),
    parsed: {}
  };
  if (parsedValue.value?.indexOf("rgb") === 0) {
    parsedValue.value = parsedValue.value.replace(/\s/g, "");
    const color = parsedValue.value;
    parsedValue.parsed = rgb2hex(parsedValue.value);
    parsedValue.parsed.type = "color";
    const colorType = /[rgba]+/g.exec(color) || [];
    parsedValue.parsed[colorType[0]] = color;
  } else if (parsedValue.property === "font-family") {
    const font = cssValue(cssPropertyValue);
    const string = parsedValue.value;
    const value = cssPropertyValue.split(/,/).map(sanitizeCSS);
    parsedValue.value = sanitizeCSS(font[0].value || font[0].string);
    parsedValue.parsed = { value, type: "font", string };
  } else {
    try {
      const value = cssValue(cssPropertyValue);
      if (value.length === 1) {
        parsedValue.parsed = value[0];
      }
      if (parsedValue.parsed.type && parsedValue.parsed.type === "number" && parsedValue.parsed.unit === "") {
        parsedValue.value = parsedValue.parsed.value;
      }
    } catch (err) {
    }
  }
  return parsedValue;
}
function checkUnicode(value) {
  if (value === Key.Ctrl) {
    return [value];
  }
  if (!Object.prototype.hasOwnProperty.call(UNICODE_CHARACTERS2, value)) {
    return new GraphemeSplitter().splitGraphemes(value);
  }
  return [UNICODE_CHARACTERS2[value]];
}
function fetchElementByJSFunction(selector, scope, referenceId) {
  if (!("elementId" in scope)) {
    return scope.execute(selector, referenceId);
  }
  const script = function(elem, id) {
    return selector.call(elem, id);
  }.toString().replace("selector", `(${selector.toString()})`);
  const args = [scope];
  if (referenceId) {
    args.push(referenceId);
  }
  return getBrowserObject31(scope).executeScript(`return (${script}).apply(null, arguments)`, args);
}
function isElement(o) {
  return typeof HTMLElement === "object" ? o instanceof HTMLElement : o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
}
function isStaleElementError(err) {
  return (
    // Chrome
    err.message.includes("stale element reference") || // Firefox
    err.message.includes("is no longer attached to the DOM") || // Safari
    err.message.toLowerCase().includes("stale element found") || // Chrome through JS execution
    err.message.includes("stale element not found in the current frame")
  );
}
function transformClassicToBidiSelector(using, value) {
  if (using === "css selector") {
    return { type: "css", value };
  }
  if (using === "xpath") {
    return { type: "xpath", value };
  }
  if (using === "link text") {
    return { type: "innerText", value };
  }
  if (using === "partial link text") {
    return { type: "innerText", value, matchType: "partial" };
  }
  throw new Error(`Can't transform classic selector ${using} to Bidi selector`);
}
async function findDeepElement(selector) {
  const browser = getBrowserObject31(this);
  const shadowRootManager2 = getShadowRootManager(browser);
  const contextManager2 = getContextManager(browser);
  const context = await contextManager2.getCurrentContext();
  const shadowRoots = shadowRootManager2.getShadowElementsByContextId(
    context,
    this.elementId
  );
  const { using, value } = findStrategy(selector, this.isW3C, this.isMobile);
  const locator = transformClassicToBidiSelector(using, value);
  const startNodes = shadowRoots.length > 0 ? shadowRoots.map((shadowRootNodeId) => ({ sharedId: shadowRootNodeId })) : this.elementId ? [{ sharedId: this.elementId }] : void 0;
  const deepElementResult = await browser.browsingContextLocateNodes({ locator, context, startNodes }).then(async (result) => {
    const nodes = result.nodes.filter((node) => Boolean(node.sharedId)).map((node) => ({
      [ELEMENT_KEY17]: node.sharedId,
      locator
    }));
    if (!this.elementId) {
      return nodes[0];
    }
    const scopedNodes = await Promise.all(nodes.map(async (node) => {
      const isIn = await browser.execute(
        elementContains,
        { [ELEMENT_KEY17]: this.elementId },
        node
      );
      return [isIn, node];
    })).then((elems) => elems.filter(([isIn]) => isIn).map(([, elem]) => elem));
    return scopedNodes[0];
  }, (err) => {
    log18.warn(`Failed to execute browser.browsingContextLocateNodes({ ... }) due to ${err}, falling back to regular WebDriver Classic command`);
    return browser.findElement(using, value);
  });
  if (!deepElementResult) {
    return new Error(`Couldn't find element with selector "${selector}"`);
  }
  return deepElementResult;
}
async function findDeepElements(selector) {
  const browser = getBrowserObject31(this);
  const shadowRootManager2 = getShadowRootManager(browser);
  const contextManager2 = getContextManager(browser);
  const context = await contextManager2.getCurrentContext();
  const shadowRoots = shadowRootManager2.getShadowElementsByContextId(
    context,
    this.elementId
  );
  const { using, value } = findStrategy(selector, this.isW3C, this.isMobile);
  const locator = transformClassicToBidiSelector(using, value);
  const startNodes = shadowRoots.length > 0 ? shadowRoots.map((shadowRootNodeId) => ({ sharedId: shadowRootNodeId })) : this.elementId ? [{ sharedId: this.elementId }] : void 0;
  const deepElementResult = await browser.browsingContextLocateNodes({ locator, context, startNodes }).then(async (result) => {
    const nodes = result.nodes.filter((node) => Boolean(node.sharedId)).map((node) => ({
      [ELEMENT_KEY17]: node.sharedId,
      locator
    }));
    if (!this.elementId) {
      return nodes;
    }
    const scopedNodes = await Promise.all(nodes.map(async (node) => {
      const isIn = await browser.execute(
        elementContains,
        { [ELEMENT_KEY17]: this.elementId },
        node
      );
      return [isIn, node];
    })).then((elems) => elems.filter(([isIn]) => isIn).map(([, elem]) => elem));
    return scopedNodes;
  }, (err) => {
    log18.warn(`Failed to execute browser.browsingContextLocateNodes({ ... }) due to ${err}, falling back to regular WebDriver Classic command`);
    return browser.findElements(using, value);
  });
  return deepElementResult;
}
async function findElement2(selector) {
  const browserObject = getBrowserObject31(this);
  const shadowRootManager2 = getShadowRootManager(browserObject);
  if (this.isBidi && typeof selector === "string" && !selector.startsWith(DEEP_SELECTOR) && !shadowRootManager2.isWithinFrame()) {
    return findDeepElement.call(this, selector);
  }
  if (typeof selector === "string" && selector.startsWith(DEEP_SELECTOR)) {
    const notFoundError = new Error(`shadow selector "${selector.slice(DEEP_SELECTOR.length)}" did not return an HTMLElement`);
    let elem = await browserObject.execute(
      `return (${querySelectorAllDeep}).apply(null, arguments)`,
      false,
      selector.slice(DEEP_SELECTOR.length),
      // hard conversion from element id to Element is done by browser driver
      this.elementId ? this : void 0
    );
    elem = Array.isArray(elem) ? elem[0] : elem;
    return getElementFromResponse(elem) ? elem : notFoundError;
  }
  if (selector && typeof selector === "object" && typeof selector.strategy === "function") {
    const { strategy, strategyName, strategyArguments } = selector;
    const notFoundError = new Error(`Custom Strategy "${strategyName}" did not return an HTMLElement`);
    let elem = await browserObject.execute(strategy, ...strategyArguments);
    elem = Array.isArray(elem) ? elem[0] : elem;
    return getElementFromResponse(elem) ? elem : notFoundError;
  }
  if (typeof selector === "string" || isPlainObject(selector)) {
    const { using, value } = findStrategy(selector, this.isW3C, this.isMobile);
    return this.elementId ? this.findElementFromElement(this.elementId, using, value) : this.findElement(using, value);
  }
  if (typeof selector === "function") {
    const notFoundError = new Error(`Function selector "${selector.toString()}" did not return an HTMLElement`);
    let elem = await fetchElementByJSFunction(selector, this);
    elem = Array.isArray(elem) ? elem[0] : elem;
    return getElementFromResponse(elem) ? elem : notFoundError;
  }
  if (isElement(selector)) {
    if (!window.__wdio_element) {
      window.__wdio_element = {};
    }
    const notFoundError = new Error("DOM Node couldn't be found anymore");
    const uid = Math.random().toString().slice(2);
    window.__wdio_element[uid] = selector;
    selector = (id) => window.__wdio_element[id];
    let elem = await fetchElementByJSFunction(selector, this, uid).catch((err) => {
      if (isStaleElementError(err)) {
        return void 0;
      }
      throw err;
    });
    elem = Array.isArray(elem) ? elem[0] : elem;
    return getElementFromResponse(elem) ? elem : notFoundError;
  }
  throw new Error(`${INVALID_SELECTOR_ERROR}, but found: \`${typeof selector}\``);
}
async function findElements(selector) {
  const browserObject = getBrowserObject31(this);
  if (typeof selector === "string" && selector.startsWith(DEEP_SELECTOR)) {
    const elems = await browserObject.execute(
      `return (${querySelectorAllDeep}).apply(null, arguments)`,
      true,
      selector.slice(DEEP_SELECTOR.length),
      // hard conversion from element id to Element is done by browser driver
      this.elementId ? this : void 0
    );
    const elemArray = Array.isArray(elems) ? elems : [elems];
    return elemArray.filter((elem) => elem && getElementFromResponse(elem));
  }
  if (isPlainObject(selector) && typeof selector.strategy === "function") {
    const { strategy, strategyArguments } = selector;
    const elems = await browserObject.execute(strategy, ...strategyArguments);
    const elemArray = Array.isArray(elems) ? elems : [elems];
    return elemArray.filter((elem) => elem && getElementFromResponse(elem));
  }
  if (typeof selector === "string" || isPlainObject(selector)) {
    const { using, value } = findStrategy(selector, this.isW3C, this.isMobile);
    return this.elementId ? this.findElementsFromElement(this.elementId, using, value) : this.findElements(using, value);
  }
  if (typeof selector === "function") {
    const elems = await fetchElementByJSFunction(selector, this);
    const elemArray = Array.isArray(elems) ? elems : [elems];
    return elemArray.filter((elem) => elem && getElementFromResponse(elem));
  }
  throw new Error(`${INVALID_SELECTOR_ERROR}, but found: \`${typeof selector}\``);
}
function verifyArgsAndStripIfElement(args) {
  function verify(arg) {
    if (arg && typeof arg === "object" && arg.constructor.name === "Element") {
      const elem = arg;
      if (!elem.elementId) {
        throw new Error(`The element with selector "${elem.selector}" you are trying to pass into the execute method wasn't found`);
      }
      return {
        [ELEMENT_KEY17]: elem.elementId,
        ELEMENT: elem.elementId
      };
    }
    return arg;
  }
  return !Array.isArray(args) ? verify(args) : args.map(verify);
}
async function getElementRect(scope) {
  const rect = await scope.getElementRect(scope.elementId);
  const defaults = { x: 0, y: 0, width: 0, height: 0 };
  if (Object.keys(defaults).some((key) => rect[key] === void 0)) {
    const rectJs = await getBrowserObject31(scope).execute(function(el) {
      if (!el || !el.getBoundingClientRect) {
        return;
      }
      const { left, top, width, height } = el.getBoundingClientRect();
      return {
        x: left + this.scrollX,
        y: top + this.scrollY,
        width,
        height
      };
    }, scope);
    Object.keys(defaults).forEach((key) => {
      if (typeof rect[key] !== "undefined") {
        return;
      }
      if (rectJs && typeof rectJs[key] === "number") {
        rect[key] = Math.floor(rectJs[key]);
      } else {
        log18.error("getElementRect", { rect, rectJs, key });
        throw new Error("Failed to receive element rects via execute command");
      }
    });
  }
  return rect;
}
function getAbsoluteFilepath(filepath) {
  return filepath.startsWith("/") || filepath.startsWith("\\") || filepath.match(/^[a-zA-Z]:\\/) ? filepath : path3.join(process.cwd(), filepath);
}
async function assertDirectoryExists(filepath) {
  const exist = await fs12.access(path3.dirname(filepath)).then(() => true, () => false);
  if (!exist) {
    throw new Error(`directory (${path3.dirname(filepath)}) doesn't exist`);
  }
}
function validateUrl(url6, origError) {
  try {
    const urlObject = new URL2(url6);
    return urlObject.href;
  } catch (err) {
    if (origError) {
      throw origError;
    }
    return validateUrl(`http://${url6}`, new Error(`Invalid URL: ${url6}`));
  }
}
async function hasElementId(element) {
  if (!element.elementId) {
    const command = element.isReactElement ? element.parent.react$.bind(element.parent) : element.isShadowElement ? element.parent.shadow$.bind(element.parent) : element.parent.$.bind(element.parent);
    element.elementId = (await command(element.selector).getElement()).elementId;
  }
  if (!element.elementId) {
    return false;
  }
  return true;
}
function addLocatorStrategyHandler(scope) {
  return (name, func) => {
    if (scope.strategies.get(name)) {
      throw new Error(`Strategy ${name} already exists`);
    }
    scope.strategies.set(name, func);
  };
}
var enhanceElementsArray = (elements, parent, selector, foundWith = "$$", props = []) => {
  const elementArray = elements;
  if (!Array.isArray(selector)) {
    elementArray.selector = selector;
  }
  const elems = selector;
  if (Array.isArray(selector) && elems.length && elems.every((elem) => elem.selector && elem.selector === elems[0].selector)) {
    elementArray.selector = elems[0].selector;
  }
  for (const [name, fn] of Object.entries(asyncIterators)) {
    elementArray[name] = fn.bind(null, elementArray);
  }
  elementArray.parent = parent;
  elementArray.foundWith = foundWith;
  elementArray.props = props;
  elementArray.getElements = async () => elementArray;
  return elementArray;
};
var isStub = (automationProtocol) => automationProtocol === "./protocol-stub.js";

// src/middlewares.ts
var COMMANDS_TO_SKIP = ["getElement", "getElements"];
var elementErrorHandler = (fn) => (commandName, commandFn) => {
  return function elementErrorHandlerCallback(...args) {
    return fn(commandName, async function elementErrorHandlerCallbackFn() {
      if (COMMANDS_TO_SKIP.includes(commandName)) {
        return fn(commandName, commandFn).apply(this, args);
      }
      const element = await implicitWait(this, commandName);
      this.elementId = element.elementId;
      this[ELEMENT_KEY18] = element.elementId;
      try {
        const result = await fn(commandName, commandFn).apply(this, args);
        const caps = getBrowserObject32(this).capabilities;
        if (caps?.browserName === "safari" && result?.error === "no such element") {
          const errorName = "stale element reference";
          const err = new Error(errorName);
          err.name = errorName;
          throw err;
        }
        return result;
      } catch (err) {
        if (err.name === "element not interactable") {
          try {
            await element.waitForClickable();
            return await fn(commandName, commandFn).apply(this, args);
          } catch (error) {
            const elementHTML = await element.getHTML();
            err.name = "webdriverio(middleware): element did not become interactable";
            err.message = `Element ${elementHTML} did not become interactable`;
            err.stack = err.stack ?? Error.captureStackTrace(err);
          }
        }
        if (err.name === "stale element reference" || isStaleElementError(err)) {
          const element2 = await refetchElement(this, commandName);
          this.elementId = element2.elementId;
          this.parent = element2.parent;
          return await fn(commandName, commandFn).apply(this, args);
        }
        throw err;
      }
    }).apply(this);
  };
};
var multiremoteHandler = (wrapCommand4) => (commandName) => {
  return wrapCommand4(commandName, function(...args) {
    const commandResults = this.instances.map((instanceName) => {
      return this[instanceName][commandName](...args);
    });
    return Promise.all(commandResults);
  });
};

// src/multiremote.ts
var MultiRemote = class _MultiRemote {
  instances = {};
  baseInstance;
  sessionId;
  /**
   * add instance to multibrowser instance
   */
  async addInstance(browserName, client) {
    this.instances[browserName] = await client;
    return this.instances[browserName];
  }
  /**
   * modifier for multibrowser instance
   */
  modifier(wrapperClient) {
    const propertiesObject = {};
    propertiesObject.commandList = { value: wrapperClient.commandList };
    propertiesObject.options = { value: wrapperClient.options };
    propertiesObject.getInstance = {
      value: (browserName) => this.instances[browserName]
    };
    for (const commandName of wrapperClient.commandList) {
      propertiesObject[commandName] = {
        value: this.commandWrapper(commandName),
        configurable: true
      };
    }
    propertiesObject.__propertiesObject__ = {
      value: propertiesObject
    };
    this.baseInstance = new MultiRemoteDriver(this.instances, propertiesObject);
    const client = Object.create(this.baseInstance, propertiesObject);
    for (const [identifier, instance] of Object.entries(this.instances)) {
      client[identifier] = instance;
    }
    return client;
  }
  /**
   * helper method to generate element objects from results, so that we can call, e.g.
   *
   * ```
   * const elem = $('#elem')
   * elem.getHTML()
   * ```
   *
   * or in case multiremote is used
   *
   * ```
   * const elems = $$('div')
   * elems[0].getHTML()
   * ```
   */
  static elementWrapper(instances, result, propertiesObject, scope) {
    const prototype = { ...propertiesObject, ...clone2(getPrototype("element")), scope: { value: "element" } };
    const element = webdriverMonad2({}, (client) => {
      for (const [i, identifier] of Object.entries(Object.keys(instances))) {
        client[identifier] = result[i];
      }
      client.instances = Object.keys(instances);
      client.isMultiremote = true;
      client.selector = result[0] ? result[0].selector : null;
      delete client.sessionId;
      return client;
    }, prototype);
    return element(this.sessionId, multiremoteHandler(scope.commandWrapper.bind(scope)));
  }
  /**
   * handle commands for multiremote instances
   */
  commandWrapper(commandName) {
    const instances = this.instances;
    const self = this;
    if (commandName === "getInstance") {
      return function(browserName) {
        if (!this[browserName]) {
          throw new Error(`Multiremote object has no instance named "${browserName}"`);
        }
        return this[browserName];
      };
    }
    return wrapCommand2(commandName, async function(...args) {
      const mElem = this;
      const scope = this.selector ? Object.entries(mElem.instances.reduce((ins, instanceName) => (
        // @ts-expect-error ToDo(Christian): deprecate
        { ...ins, [instanceName]: mElem[instanceName] }
      ), {})) : Object.entries(instances);
      const result = await Promise.all(
        scope.map(
          ([, instance]) => instance[commandName](...args)
        )
      );
      if (commandName === "$") {
        const elem = _MultiRemote.elementWrapper(instances, result, this.__propertiesObject__, self);
        return elem;
      } else if (commandName === "$$") {
        const zippedResult = zip(...result);
        return zippedResult.map((singleResult) => _MultiRemote.elementWrapper(instances, singleResult, this.__propertiesObject__, self));
      }
      return result;
    });
  }
};
var MultiRemoteDriver = class {
  instances;
  isMultiremote = true;
  __propertiesObject__;
  constructor(instances, propertiesObject) {
    this.instances = Object.keys(instances);
    this.__propertiesObject__ = propertiesObject;
  }
  on(eventName, emitter) {
    this.instances.forEach((instanceName) => this.getInstance(instanceName).on(eventName, emitter));
    return void 0;
  }
  once(eventName, emitter) {
    this.instances.forEach((instanceName) => this.getInstance(instanceName).once(eventName, emitter));
    return void 0;
  }
  emit(eventName, emitter) {
    return this.instances.map(
      (instanceName) => this.getInstance(instanceName).emit(eventName, emitter)
    ).some(Boolean);
  }
  eventNames() {
    return this.instances.map(
      (instanceName) => this.getInstance(instanceName).eventNames()
    );
  }
  getMaxListeners() {
    return this.instances.map(
      (instanceName) => this.getInstance(instanceName).getMaxListeners()
    );
  }
  listenerCount(eventName) {
    return this.instances.map(
      (instanceName) => this.getInstance(instanceName).listenerCount(eventName)
    );
  }
  listeners(eventName) {
    return this.instances.map(
      (instanceName) => this.getInstance(instanceName).listeners(eventName)
    ).reduce((prev, cur) => {
      prev.concat(cur);
      return prev;
    }, []);
  }
  removeListener(eventName, emitter) {
    this.instances.forEach((instanceName) => this.getInstance(instanceName).removeListener(eventName, emitter));
    return void 0;
  }
  removeAllListeners(eventName) {
    this.instances.forEach((instanceName) => this.getInstance(instanceName).removeAllListeners(eventName));
    return void 0;
  }
};

// src/utils/SevereServiceError.ts
var SevereServiceError = class extends Error {
  constructor(message = "Severe Service Error occurred.") {
    super(message);
    this.name = "SevereServiceError";
  }
};

// src/utils/detectBackend.ts
var DEFAULT_HOSTNAME = "127.0.0.1";
var DEFAULT_PORT = 4444;
var DEFAULT_PROTOCOL = "http";
var DEFAULT_PATH = "/";
var LEGACY_PATH = "/wd/hub";
var REGION_MAPPING = {
  "us": "us-west-1.",
  // default endpoint
  "eu": "eu-central-1.",
  "eu-central-1": "eu-central-1.",
  "us-east-1": "us-east-1.",
  "us-east-4": "us-east-4.",
  "apac": "apac-southeast-1.",
  "apac-southeast-1": "apac-southeast-1"
};
function getSauceEndpoint(region, { isRDC, isVisual } = {}) {
  const shortRegion = REGION_MAPPING[region] ? region : "us";
  if (isRDC) {
    return `${shortRegion}1.appium.testobject.com`;
  } else if (isVisual) {
    return "hub.screener.io";
  }
  return `ondemand.${REGION_MAPPING[shortRegion]}saucelabs.com`;
}
function detectBackend(options = {}) {
  const { port, hostname, user, key, protocol, region, headless, path: path4, capabilities } = options;
  if (typeof user === "string" && typeof key === "string" && key.length === 20) {
    return {
      protocol: protocol || "https",
      hostname: hostname || "hub-cloud.browserstack.com",
      port: port || 443,
      path: path4 || LEGACY_PATH
    };
  }
  if (typeof user === "string" && typeof key === "string" && key.length === 32) {
    return {
      protocol: protocol || "https",
      hostname: hostname || "hub.testingbot.com",
      port: port || 443,
      path: path4 || LEGACY_PATH
    };
  }
  const isVisual = Boolean(!Array.isArray(capabilities) && capabilities && capabilities["sauce:visual"]?.apiKey);
  if (typeof user === "string" && typeof key === "string" && key.length === 36 || // Or only RDC or visual
  isVisual) {
    const sauceRegion = headless ? "us-east-1" : region;
    return {
      protocol: protocol || "https",
      hostname: hostname || getSauceEndpoint(sauceRegion, { isVisual }),
      port: port || 443,
      path: path4 || LEGACY_PATH
    };
  }
  if (typeof user === "string" && typeof key === "string" && key.length === 50) {
    return {
      protocol: protocol || DEFAULT_PROTOCOL,
      hostname: hostname || "hub.lambdatest.com",
      port: port || 80,
      path: path4 || LEGACY_PATH
    };
  }
  if (
    /**
     * user and key are set in config
     */
    (typeof user === "string" || typeof key === "string") && /**
     * but no custom WebDriver endpoint was configured
     */
    !hostname
  ) {
    throw new Error(
      'A "user" or "key" was provided but could not be connected to a known cloud service (Sauce Labs, Browerstack, Testingbot or Lambdatest). Please check if given user and key properties are correct!'
    );
  }
  if (hostname || port || protocol || path4) {
    return {
      hostname: hostname || DEFAULT_HOSTNAME,
      port: port || DEFAULT_PORT,
      protocol: protocol || DEFAULT_PROTOCOL,
      path: path4 || DEFAULT_PATH
    };
  }
  return { hostname, port, protocol, path: path4 };
}

// src/protocol-stub.ts
import { capabilitiesEnvironmentDetector } from "@wdio/utils";
var ProtocolStub = class {
  static async newSession(options) {
    const capabilities = emulateSessionCapabilities(options.capabilities);
    const browser = {
      options,
      capabilities,
      requestedCapabilities: capabilities,
      customCommands: [],
      // internally used to transfer custom commands to the actual protocol instance
      overwrittenCommands: [],
      // internally used to transfer overwritten commands to the actual protocol instance
      commandList: [],
      ...capabilitiesEnvironmentDetector(capabilities)
    };
    browser.addCommand = (...args) => browser.customCommands.push(args);
    browser.overwriteCommand = (...args) => browser.overwrittenCommands.push(args);
    return browser;
  }
  /**
   * added just in case user wants to somehow reload webdriver before it was started.
   */
  static reloadSession() {
    throw new Error("Protocol Stub: Make sure to start the session before reloading it.");
  }
  static attachToSession(options, modifier) {
    if (options || !modifier) {
      throw new Error("You are trying to attach to a protocol stub, this should never occur, please file an issue.");
    }
    return modifier({
      commandList: []
    });
  }
};
function emulateSessionCapabilities(caps) {
  const capabilities = {};
  Object.entries(caps).forEach(([key, value]) => {
    const newKey = key.replace("appium:", "");
    capabilities[newKey] = value;
  });
  const c = "alwaysMatch" in caps ? caps.alwaysMatch : caps;
  if (c.browserName && c.browserName.toLowerCase() === "chrome") {
    capabilities["goog:chromeOptions"] = {};
  }
  return capabilities;
}

// src/utils/driver.ts
var webdriverImport;
async function getProtocolDriver(options) {
  if (options.automationProtocol === "./protocol-stub.js" /* stub */) {
    return { Driver: ProtocolStub, options };
  }
  if (typeof options.user === "string" && typeof options.key === "string") {
    Object.assign(options, detectBackend(options));
  }
  const Driver = webdriverImport || (await import(
    /* @vite-ignore */
    options.automationProtocol || "webdriver"
  )).default;
  return { Driver, options };
}

// src/dialog.ts
var dialogManager = /* @__PURE__ */ new Map();
function getDialogManager(browser) {
  const existingDialogManager = dialogManager.get(browser);
  if (existingDialogManager) {
    return existingDialogManager;
  }
  const newContext = new DialogManager(browser);
  dialogManager.set(browser, newContext);
  return newContext;
}
var DialogManager = class {
  #browser;
  #initialize;
  #autoHandleDialog = true;
  constructor(browser) {
    this.#browser = browser;
    if (!browser.isBidi || process.env.VITEST_WORKER_ID || browser.options?.automationProtocol !== "webdriver") {
      this.#initialize = Promise.resolve(true);
      return;
    }
    this.#initialize = this.#browser.sessionSubscribe({
      events: ["browsingContext.userPromptOpened"]
    }).then(() => true, () => false);
    this.#browser.on("_dialogListenerRegistered", () => this.#switchListenerFlag(false));
    this.#browser.on("_dialogListenerRemoved", () => this.#switchListenerFlag(true));
    this.#browser.on("browsingContext.userPromptOpened", this.#handleUserPrompt.bind(this));
  }
  async initialize() {
    return this.#initialize;
  }
  /**
   * capture shadow root elements propagated through console.debug
   */
  async #handleUserPrompt(log19) {
    if (this.#autoHandleDialog) {
      return this.#browser.browsingContextHandleUserPrompt({
        accept: false,
        context: log19.context
      });
    }
    const dialog = new Dialog(log19, this.#browser);
    this.#browser.emit("dialog", dialog);
  }
  /**
   * Is called when a new dialog listener is registered with the `dialog` name.
   * In these cases we set a flag to the `#listener` map to indicate that we
   * are listening to dialog events for this page in this context.
   */
  #switchListenerFlag(value) {
    this.#autoHandleDialog = value;
  }
};
var Dialog = class {
  #browser;
  #context;
  #message;
  #defaultValue;
  #type;
  constructor(event, browser) {
    this.#message = event.message;
    this.#defaultValue = event.defaultValue;
    this.#type = event.type;
    this.#context = event.context;
    this.#browser = browser;
  }
  message() {
    return this.#message;
  }
  defaultValue() {
    return this.#defaultValue;
  }
  type() {
    return this.#type;
  }
  /**
   * Returns when the dialog has been accepted.
   *
   * @alias dialog.accept
   * @param {string=} promptText  A text to enter into prompt. Does not cause any effects if the dialog's type is not prompt.
   * @returns {Promise<void>}
   */
  async accept(userText) {
    await this.#browser.browsingContextHandleUserPrompt({
      accept: true,
      context: this.#context,
      userText
    });
  }
  async dismiss() {
    await this.#browser.browsingContextHandleUserPrompt({
      accept: false,
      context: this.#context
    });
  }
};

// src/index.ts
var Key2 = Key;
var SevereServiceError2 = SevereServiceError;
var remote = async function(params, remoteModifier) {
  const keysToKeep = Object.keys(process.env.WDIO_WORKER_ID ? params : DEFAULTS);
  const config = validateConfig(WDIO_DEFAULTS, params, keysToKeep);
  await enableFileLogging(config.outputDir);
  logger19.setLogLevelsConfig(config.logLevels, config.logLevel);
  const modifier = (client, options2) => {
    Object.assign(options2, Object.entries(config).reduce((a, [k, v]) => typeof v === "undefined" ? a : { ...a, [k]: v }, {}));
    if (typeof remoteModifier === "function") {
      client = remoteModifier(client, options2);
    }
    return client;
  };
  const { Driver, options } = await getProtocolDriver({ ...params, ...config });
  const prototype = getPrototype("browser");
  const instance = await Driver.newSession(options, modifier, prototype, wrapCommand3);
  if (params.framework && !isStub(params.automationProtocol)) {
    const origAddCommand = instance.addCommand.bind(instance);
    instance.addCommand = (name, fn, attachToElement) => origAddCommand(name, fn, attachToElement);
    const origOverwriteCommand = instance.overwriteCommand.bind(instance);
    instance.overwriteCommand = (name, fn, attachToElement) => origOverwriteCommand(name, fn, attachToElement);
  }
  instance.addLocatorStrategy = addLocatorStrategyHandler(instance);
  await Promise.all([
    getShadowRootManager(instance).initialize(),
    getNetworkManager(instance).initialize(),
    getDialogManager(instance).initialize(),
    getContextManager(instance).initialize()
  ]);
  return instance;
};
var attach = async function(attachOptions) {
  const params = {
    automationProtocol: "webdriver" /* webdriver */,
    ...attachOptions,
    ...detectBackend(attachOptions.options),
    capabilities: attachOptions.capabilities || {},
    requestedCapabilities: attachOptions.requestedCapabilities || {}
  };
  const prototype = getPrototype("browser");
  const { Driver } = await getProtocolDriver(params);
  const driver = Driver.attachToSession(
    params,
    void 0,
    prototype,
    wrapCommand3
  );
  driver.addLocatorStrategy = addLocatorStrategyHandler(driver);
  await driver._bidiHandler?.connect().then(() => Promise.all([
    getShadowRootManager(driver).initialize(),
    getNetworkManager(driver).initialize(),
    getDialogManager(driver).initialize(),
    getContextManager(driver).initialize()
  ]));
  return driver;
};
var multiremote = async function(params, { automationProtocol } = {}) {
  const multibrowser = new MultiRemote();
  const browserNames = Object.keys(params);
  await Promise.all(
    browserNames.map(async (browserName) => {
      const instance = await remote(params[browserName]);
      return multibrowser.addInstance(browserName, instance);
    })
  );
  const prototype = getPrototype("browser");
  const sessionParams = isStub(automationProtocol) ? void 0 : {
    sessionId: "",
    isW3C: multibrowser.instances[browserNames[0]].isW3C,
    logLevel: multibrowser.instances[browserNames[0]].options.logLevel
  };
  const ProtocolDriver = automationProtocol && isStub(automationProtocol) ? (await import(
    /* @vite-ignore */
    automationProtocol
  )).default : WebDriver;
  const driver = ProtocolDriver.attachToSession(
    sessionParams,
    multibrowser.modifier.bind(multibrowser),
    prototype,
    wrapCommand3
  );
  if (!isStub(automationProtocol)) {
    const origAddCommand = driver.addCommand.bind(driver);
    driver.addCommand = (name, fn, attachToElement) => {
      return origAddCommand(
        name,
        fn,
        attachToElement,
        Object.getPrototypeOf(multibrowser.baseInstance),
        multibrowser.instances
      );
    };
    const origOverwriteCommand = driver.overwriteCommand.bind(driver);
    driver.overwriteCommand = (name, fn, attachToElement) => {
      return origOverwriteCommand(
        name,
        fn,
        attachToElement,
        Object.getPrototypeOf(multibrowser.baseInstance),
        multibrowser.instances
      );
    };
  }
  driver.addLocatorStrategy = addLocatorStrategyHandler(driver);
  return driver;
};
export {
  Key2 as Key,
  KeyAction,
  PointerAction,
  SevereServiceError2 as SevereServiceError,
  WheelAction,
  attach,
  buttonValue,
  multiremote,
  remote
};
/*!
 * ensure that timeout and interval are set properly
 */
